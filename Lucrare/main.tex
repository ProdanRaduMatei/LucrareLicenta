\documentclass[12pt,a4paper]{report} % ✅ Good

% ===== PACKAGES =====
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{float}
\usepackage{caption}
\usepackage{listings}
\usepackage[usenames]{color}
\usepackage{enumitem}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage[numbers]{natbib}
\usepackage{listings}
\usepackage{xcolor}

\lstset{
  language=Java,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{teal},
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  breaklines=true,
  breakatwhitespace=false,
  frame=single,
  showstringspaces=false,
  tabsize=2
}

% ===== SETTINGS =====
\geometry{left=3cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\setlength{\headheight}{14.5pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}
\lhead{SeatSurfer Thesis}

\begin{document}

% ===== TITLE PAGE =====
\begin{titlepage}
    \centering
    \textsc{\LARGE Babeș-Bolyai University}\\[0.5cm]
    \textsc{\Large Faculty of Mathematics and Computer Science}\\[1.5cm]
    {\huge\bfseries SeatSurfer: A Database-Centric Seat Management System\\[0.4cm]}
    \vspace{1.5cm}
    \Large
    \textbf{Bachelor's Thesis}\\[0.5cm]
    \begin{flushleft}
        \textbf{Author:} Prodan Radu-Matei\\
        \textbf{Supervisor:} Lect. Dr. Pop Emilia \\
        \textbf{Specialization:} Computer Science and Mathematics (English) \\
        \textbf{Year:} 2025
    \end{flushleft}
    \vfill
\end{titlepage}

% ===== ABSTRACT =====
\chapter*{Abstract}

Modern workplaces are increasingly adopting hybrid work models, where employees alternate between remote and on-site schedules. This evolution has introduced a major logistical problem: the efficient, flexible management of office seating. Traditional fixed desk assignments are no longer effective in such dynamic environments, leading to underutilized spaces, booking conflicts, and administrative overhead.

SeatSurfer directly addresses this challenge by providing a centralized, real-time seat reservation and management platform. The application enables employees to view available seats, make reservations, and manage their bookings through a responsive cross-platform interface built with Flutter. Administrators can configure office layouts, monitor occupancy levels, and maintain control over space allocation.

The system relies on a robust backend developed with Spring Boot and PostgreSQL, ensuring data integrity, transaction safety, and rapid query performance. Security is enforced through role-based access control implemented with Spring Security, differentiating user and administrator privileges. SeatSurfer's design emphasizes modularity, allowing future extensions such as intelligent seat suggestions, occupancy prediction, and hardware sensor integrations.

Development followed Agile methodology, enabling iterative delivery, continuous feedback, and rigorous testing. SeatSurfer demonstrates how modern database-driven architectures, combined with cloud-ready deployment strategies and user-centric design, can effectively solve critical problems of space management in hybrid work environments.

This work is the result of my own activity. I have neither given nor received
unauthorised assistance on this work.

\vspace{0.5cm}
% \noindent \textbf{Keywords:} hybrid work, office management, seat reservation, database systems, Spring Boot, Flutter, workplace optimization

% ===== TOC =====
\tableofcontents
\newpage

% ===== CHAPTER 1 =====
\section*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

\section*{Context and Motivation}
\addcontentsline{toc}{section}{Context and Motivation}

The COVID-19 pandemic catalyzed a fundamental shift in workplace models. Organizations worldwide began transitioning to hybrid systems, where employees alternate between working remotely and on-site. This shift introduced new logistical challenges — particularly regarding the use and optimization of physical office space \cite{baker2021hybrid}.

Smart offices use IoT and AI to adapt to dynamic user demands and hybrid scheduling \cite{nayyar2021smart}.

The traditional static assignment of desks became inefficient in a flexible environment. Fixed seating arrangements often led to large areas of underutilized space, while certain days saw unexpected crowding. As workforces became more mobile and flexible, the need for a dynamic, real-time management solution became critical. Companies needed a way to dynamically manage and track seat usage, prevent overcrowding, respect safety regulations, and offer employees autonomy over their workspace choices.

Beyond logistical issues, poor space management directly impacts organizational costs. Maintaining large offices with inefficient seat utilization leads to increased operational expenses, underused real estate, and employee dissatisfaction due to lack of visibility or transparency in desk availability.

While several commercial seat booking and space management solutions exist, they present significant barriers to adoption. Many are either prohibitively expensive for small and mid-sized organizations, overly complex for simple needs, or lack proper integrations with existing internal tools. Furthermore, dependency on third-party cloud services often raises concerns about data ownership, security, and customization flexibility.

In this context, SeatSurfer was conceived as a lightweight, customizable, and secure solution to the growing challenges of hybrid workplace management. By leveraging open technologies and focusing on modular, database-driven architecture, SeatSurfer empowers organizations to regain control over their office spaces without the overhead of complex, vendor-dependent platforms.

\section*{Purpose and Research Objectives}
\addcontentsline{toc}{section}{Purpose and Research Objectives}

This thesis is driven by the goal of designing and implementing a robust, modular, and database-centric platform for intelligent seat management in hybrid work environments. The development of SeatSurfer seeks not only to deliver a functional software product but also to demonstrate best practices in full-stack system design, scalable architecture, and secure data handling.

The specific research and development objectives of this project are:

\begin{itemize}
    \item \textbf{Development of a fully functional booking platform:} SeatSurfer aims to provide a complete seat reservation system built entirely with open technologies, ensuring transparency, extensibility, and vendor independence.
    
    \item \textbf{Implementation of secure, role-based access control:} A core requirement is to differentiate functionalities between regular users and administrators, enforcing strict access control policies and ensuring that sensitive administrative operations are properly protected.
    
    \item \textbf{Optimization of the relational data model:} The database schema is designed to facilitate real-time occupancy tracking, dynamic seat layouts, and efficient query performance, enabling the system to scale to varying organizational sizes without degradation.
    
    \item \textbf{Validation through systematic testing and benchmarking:} The application must be rigorously evaluated through functional testing, security assessments, and performance benchmarks to confirm its reliability and readiness for real-world deployment.
    
    \item \textbf{Contribution to database-centric application design knowledge:} By analyzing the challenges and trade-offs encountered during development, this thesis offers insights into how database normalization, RESTful API architecture, and modular full-stack design can be effectively combined in modern applications.
\end{itemize}

Through these objectives, the project not only delivers a practical solution to the hybrid workspace management problem but also contributes academically to the field of applied software engineering and database systems.

\section*{Structure of the Thesis}
\addcontentsline{toc}{section}{Structure of the Thesis}

This thesis is structured into five core chapters: \textit{Introduction}, \textit{Research in the Domain}, \textit{Theoretical Foundations}, \textit{Application and Implementation}, and \textit{Conclusion and Future Directions}.

\textbf{Introduction} – outlines the context and motivation behind the project, defines its objectives, and explains the relevance of the topic in the post-pandemic era of hybrid work. This section also highlights the personal contribution and provides a high-level overview of the solution proposed.

\textbf{Chapter 1: Research in the Domain – Review of Existing Solutions and Academic Approaches} – explores the current landscape of commercial and academic tools for workspace and seat management. It critically analyzes their features, limitations, and applicability in flexible office environments, establishing a clear rationale for developing a custom platform.

\textbf{Chapter 2: Theoretical Foundations – Technologies and System Architecture} – presents the core technologies used in the project, including Flutter for the frontend, Spring Boot for backend services, and PostgreSQL as the database engine. It also details the system architecture, deployment model, and data flow design, providing a comprehensive technical foundation.

\textbf{Chapter 3: Application and Implementation – SeatSurfer Platform} – describes the developed platform in depth, covering both user-facing and administrative functionalities. The chapter includes UI illustrations, architectural diagrams, role-based access mechanisms, and detailed descriptions of booking logic, configuration tools, and analytics features. It also presents the applied testing strategy and performance benchmarks.

\textbf{Conclusion and Future Directions} – summarizes the key findings and results of the project, emphasizing the platform's contributions to hybrid workplace optimization. It also outlines directions for future work, including AI-powered seat suggestions, IoT integration, multitenancy support, and academic research opportunities.

\newpage

% ===== CHAPTER 2 =====
\chapter{Research in the Domain}

\section{Commercial Tools and Industry Trends}

The rise of hybrid and hot-desking models in companies has led to a proliferation of software products designed to manage workplace occupancy. Notable examples include:
\begin{itemize}
    \item \textbf{Robin} - Offers interactive maps and analytics, tailored for enterprise-level integration
    \item \textbf{Deskbird} - Focuses on user-friendliness and mobile-first experiences
    \item \textbf{Skedda} - Provides a more general space booking platform used in co-working spaces
    \item \textbf{Microsoft Places / Outlook Room Finder} - Integrated into Microsoft's ecosystem, targeted at calendar-based reservations
\end{itemize}

While these tools offer functional solutions, they come with limitations:
\begin{itemize}
    \item High subscription costs for teams
    \item Limited customizability
    \item Vendor lock-in with cloud infrastructure
    \item Lack of transparent access to data models or APIs
\end{itemize}

\section{Academic and Open Source Approaches}

Several academic research initiatives and open-source projects have tackled problems related to scheduling systems, particularly in the context of classroom management, laboratory reservations, and resource allocation in educational environments.

% For example, systems like Booked Scheduler\footnote{\url{https://www.bookedscheduler.com/}} (formerly phpScheduleIt) offer open-source scheduling for facilities, but are primarily designed for fixed room booking without dynamic seat management. Similarly, research projects such as RESERVATION \cite{ko_reservation_2015} focus on resource allocation in educational contexts, often without emphasis on flexible layouts or mobile-friendly interfaces.

However, while valuable, these systems exhibit significant limitations when evaluated against the demands of a modern hybrid workplace. Common shortcomings include:

\begin{itemize}
\item \textbf{Administrative Focus:} Many academic or open-source systems are designed primarily for administrators to manage assets but do not offer rich, real-time user experiences for employees or students.
% \item \textbf{Legacy Technology Stacks:} A large proportion of existing solutions rely on older web architectures (PHP, basic SQL), making them less adaptable to mobile usage or real-time operations \cite{paas_trends}.
\item \textbf{Poor Usability and Limited Mobile Access:} Usability and accessibility are often secondary priorities, resulting in interfaces that are non-responsive or difficult to use on smartphones and tablets.
\item \textbf{Static Data Models:} Many systems assume static resource inventories rather than dynamically changing floor plans, which are essential in flexible hybrid workspaces.
\item \textbf{Security and Access Control Gaps:} Several open-source schedulers lack modern authentication mechanisms like OAuth2 or role-based access control, limiting their applicability in corporate environments.
\end{itemize}

Moreover, recent research highlights how IoT-enabled seat booking systems can improve space utilization through real-time monitoring and adaptive control strategies, aligning directly with SeatSurfer's design goals \cite{rahman2020iot}.

In contrast, \textbf{SeatSurfer} provides a dynamic, scalable, and secure system explicitly designed to meet the needs of hybrid workplaces. By leveraging modern frameworks such as Flutter for the frontend and Spring Boot for the backend, and by focusing on user-centered design and real-time interaction, SeatSurfer addresses gaps left open by earlier academic and open-source efforts.

The platform offers the following key advantages:
\begin{itemize}
\item \textbf{Full-stack architecture:} A responsive, modern user interface developed in Flutter, integrated with a robust, RESTful backend powered by Spring Boot.
\item \textbf{Custom data model:} A relational schema specifically designed for flexible desk and seat management, supporting dynamic layouts and real-time availability tracking.
\item \textbf{Transparency and extensibility:} An openly structured database optimized for future enhancements, including advanced analytics, reporting modules, and integrations with third-party tools or sensors.
\end{itemize}

\section{Innovations Introduced by SeatSurfer}

SeatSurfer introduces a series of key innovations that clearly distinguish it from conventional off-the-shelf SaaS seat management platforms. Rather than enforcing a rigid, vendor-controlled framework, SeatSurfer was designed with openness, flexibility, and user empowerment as core principles.

First, SeatSurfer enables organizations to retain full sovereignty over their infrastructure by offering a self-hosted deployment model. Unlike SaaS offerings that require data and operations to reside on third-party servers, SeatSurfer can be installed and managed internally, ensuring complete ownership of sensitive corporate data and compliance with internal security policies.

Second, the system offers full control over workspace layouts, seat configurations, and booking rules. Administrators are not constrained by predefined templates or limited customization options. Every aspect of the seat management logic — from the physical floor map to booking restrictions and user access levels — can be tailored to the organization's specific operational needs.

Third, SeatSurfer introduces intuitive, real-time floor visualization capabilities. Employees can interact with dynamic seat layouts that accurately reflect the current availability, allowing for immediate booking decisions. This visual approach improves user experience, enhances booking efficiency, and reduces friction compared to text-based or list-driven interfaces commonly found in legacy systems.

Finally, SeatSurfer is designed as a modular platform ready for future enhancements. Its architecture supports the seamless integration of additional features such as occupancy analytics, automated notifications, AI-driven seat suggestions, or Internet-of-Things (IoT) sensor inputs without major restructuring. This extensibility ensures that SeatSurfer can evolve alongside organizational requirements, offering a long-term, future-proof solution for hybrid workspaces.

\section{Benefits of the Custom-Built Architecture}

Developing SeatSurfer entirely in-house brings both pedagogical and strategic advantages that extend far beyond the immediate technical implementation.

First, from an educational standpoint, designing the entire system — from database schema to frontend interaction — fosters a much deeper understanding of full-stack architectures. It exposes developers to critical aspects of modern software engineering, including client-server communication, database normalization, API design, security best practices, and cross-platform user interface development. This holistic exposure is rarely achievable when working with pre-packaged third-party solutions.

Second, the custom-built approach enforces best practices in software engineering, such as reusable component design, clean separation of concerns between application layers, and modular code organization. By adhering to these principles, SeatSurfer achieves greater maintainability, scalability, and adaptability over time.

Strategically, an in-house system offers unparalleled flexibility. Unlike closed commercial platforms, SeatSurfer can integrate seamlessly with existing internal tools such as Single Sign-On (SSO) systems, employee databases, building access controls, or corporate calendars. New features and integrations can be developed without reliance on external vendors or prohibitive licensing models.

Moreover, SeatSurfer dramatically improves organizational responsiveness to change. As company needs evolve — for example, relocating offices, reconfiguring seating plans, or adjusting reservation policies — the system can be updated swiftly and at minimal cost. This agility is a significant strategic asset in the post-pandemic era of hybrid work, where office configurations may need to change rapidly based on employee attendance patterns, health guidelines, or space optimization strategies.

Finally, by combining academic software development principles with practical usability goals, SeatSurfer establishes itself as a viable, sustainable alternative to expensive commercial seat management platforms. It empowers organizations with full ownership of their systems and data, providing the rare combination of customization, cost efficiency, operational control, and technical extensibility.

\newpage

% ===== CHAPTER 3 =====
\chapter{Theoretical Part}
\section{Technologies Used}

\subsection{Overview of the Stack}

The SeatSurfer platform was built using a carefully selected, modular technology stack designed to address the unique requirements of hybrid office space management. This stack supports rapid feature development, cross-platform deployment, secure access control, and efficient database operations. Each component was chosen for its maturity, community support, and alignment with the project's goals of scalability, usability, and robustness.

\begin{itemize}
    \item \textbf{Frontend:} Flutter is Google's open-source UI toolkit that enables developers to build high-performance applications from a single codebase for Android, iOS, web, and desktop. For SeatSurfer, Flutter powers the entire user interface, including seat layout visualizations, calendar-based bookings, and responsive administrative dashboards. Its widget-based, declarative framework facilitates the creation of clean, interactive designs while its hot-reload feature greatly speeds up the development and testing cycle. The use of Flutter ensures platform consistency and significantly reduces the time and effort required to build and maintain separate mobile and web applications.

    \item \textbf{Backend:} Spring Boot serves as the backbone of SeatSurfer's backend logic, offering a rapid way to build production-ready RESTful APIs. Leveraging the broader Spring ecosystem, it provides robust dependency injection, automatic configuration, and a layered architecture that separates business logic from presentation and persistence concerns. In SeatSurfer, Spring Boot handles all core services such as booking validation, user management, access control, and database interactions. It also facilitates rapid prototyping and testing with embedded servers and in-memory databases for development purposes.

    \item \textbf{Database:} PostgreSQL is a powerful, enterprise-grade relational database system that offers full SQL compliance, ACID transactions, and advanced data modeling capabilities. It was selected for SeatSurfer due to its performance with complex relational queries, support for constraints and foreign keys, and ability to handle normalized schemas efficiently. The schema includes interconnected entities such as users, floors, seats, and bookings, all maintained with referential integrity. PostgreSQL also supports indexing strategies that optimize lookup speed for real-time seat availability and conflict detection during booking operations.

    \item \textbf{Authentication:} \textit{Spring Security} — This framework integrates seamlessly with Spring Boot to provide comprehensive authentication and authorization capabilities. It enforces access control via role-based permissions (e.g., USER vs. ADMIN), supports form-based and token-based login methods, and protects endpoints against unauthorized access. In SeatSurfer, user credentials are securely stored using BCrypt hashing, and all protected operations (such as floor configuration or booking deletion) are guarded by endpoint-level access rules. This guarantees that users can only access resources appropriate to their assigned roles.

    \item \textbf{Other Tools:}
    \begin{itemize}
        \item \textbf{Postman} — An API client used extensively for testing and debugging backend endpoints. It allowed developers to verify request and response formats, test edge cases (e.g., double bookings), and inspect HTTP headers for role-based access testing.
        
        \item \textbf{GitHub} — Served as the version control system, enabling collaborative development, pull request reviews, issue tracking, and continuous integration. Git branches were used to isolate features and fix bugs in parallel by different team members.
        
        \item \textbf{Trello} — A task management tool used to organize the team's Agile workflow. Trello boards contained categorized task columns such as To Do, In Progress, In Review, and Done, which facilitated sprint planning, daily stand-ups, and retrospectives.
        
        \item \textbf{IntelliJ IDEA} — The primary integrated development environment for Java and Spring Boot development. Its features like live templates, refactoring tools, integrated terminal, and Maven support improved backend productivity and code maintainability.
        
        \item \textbf{Visual Studio Code} — Used for developing and debugging the Flutter frontend. Its extensive plugin ecosystem and support for Dart and Flutter extensions made it the ideal editor for building responsive UIs and integrating with REST APIs.
    \end{itemize}
\end{itemize}

This stack was deliberately selected to balance development speed, scalability, cross-platform support, and ease of deployment. By using technologies that are open-source and widely adopted in industry, SeatSurfer ensures long-term maintainability and adaptability to future requirements.

\subsection{Flutter: The User Interface Layer}

Flutter, developed by Google, is a modern open-source framework that empowers developers to build natively compiled applications from a single codebase for Android, iOS, web, and desktop. This cross-platform capability is crucial for projects like SeatSurfer, which aim to provide a seamless and consistent user experience across a variety of devices without duplicating development effort. Flutter supports expressive UIs for mobile, desktop, and web platforms from a single codebase \cite{google2022flutter}. Responsive and intuitive layouts are essential for usability in hybrid booking apps, making Flutter a strong fit for this domain \cite{verma2023flutter}.

Flutter's architecture is built around a high-performance rendering engine (Skia), allowing it to bypass native UI components and instead render every pixel directly, ensuring full control over the look and feel of the application. It provides a fast development cycle, with features such as stateful hot reload, making it ideal for iterative UI development and debugging.

Key features that made Flutter suitable for SeatSurfer include:

\begin{itemize}
\item \textbf{Declarative widget system:} Inspired by React, Flutter uses a tree of composable widgets for building UIs. Each widget describes part of the interface, and the framework efficiently rebuilds only the affected parts of the UI when state changes occur. This approach promotes reusable, testable components.
\item \textbf{Rich UI controls and animation libraries:} Flutter includes a vast set of pre-built widgets that adhere to both Material Design (Android) and Cupertino (iOS) principles, along with powerful animation APIs for building polished interfaces. This enabled the SeatSurfer team to design intuitive transitions, dialogs, and dynamic visual feedback (e.g., seat hover and selection animations).
\item \textbf{Integrated HTTP packages:} The \texttt{http} and \texttt{dio} packages allow Flutter to easily consume RESTful APIs. These were used extensively in SeatSurfer to communicate with the backend services for actions like login, fetching seat availability, creating or canceling bookings, and accessing analytics data.
\end{itemize}

In the context of SeatSurfer, Flutter was instrumental in implementing a responsive, interactive interface tailored for both regular users and administrators:

\begin{itemize}
\item \textbf{Visual matrix-based seat layout:} A dynamic, color-coded grid that visually represents the seat availability on each floor. Each seat cell can be tapped to trigger bookings or view status, with real-time UI updates based on API responses.
\item \textbf{Interactive date picker and floor selection screens:} These components allow users to quickly select the date and floor for which they want to view or reserve seats. These selections trigger live data updates from the backend, ensuring that users always see accurate seat availability.
\item \textbf{Responsive admin dashboards and booking listings:} Admins access a separate interface for configuring layouts, viewing usage statistics, and managing bookings. The UI adapts fluidly across devices and screen sizes, maintaining usability whether accessed from a mobile phone, tablet, or desktop browser.
\end{itemize}

By leveraging Flutter's cross-platform consistency, rich visual tools, and high development velocity, the SeatSurfer frontend achieved a professional, mobile-first interface with minimal overhead. This not only improved user experience but also accelerated development and testing cycles throughout the project.

\subsection{Spring Boot: RESTful Backend}

Spring Boot is a robust, production-grade framework built on top of the Spring ecosystem. It simplifies the setup and development of stand-alone, enterprise-grade applications in Java by providing pre-configured defaults, embedded servers (like Tomcat), and a vast ecosystem of modular components. Spring Boot enables rapid development of RESTful APIs, supports microservice architectures, and includes essential features such as dependency injection, aspect-oriented programming, and robust testing frameworks. Spring Boot simplifies the development of REST APIs and integrates seamlessly with Spring Security \cite{baeldung2023springapi}.

At the core of Spring Boot lies the concept of convention over configuration, significantly reducing boilerplate code and letting developers focus on business logic. The framework also integrates smoothly with popular tools and technologies such as Maven, Gradle, and Docker, making it ideal for scalable backend services.

In the SeatSurfer platform, Spring Boot serves as the backbone of the server-side logic. It is responsible for managing business workflows, securing endpoints, validating input data, and coordinating database operations. Specifically, Spring Boot handles:

\begin{itemize}
\item \textbf{Booking creation, validation, and cancellation logic:} When a user attempts to book a seat, the system checks for availability, prevents double-booking, and persists the request. Similar workflows exist for booking cancellation and conflict resolution, all encapsulated within service-layer components.
\item \textbf{Role-based endpoint security using Spring Security:} Spring Security provides a comprehensive authentication and authorization framework. In SeatSurfer, it ensures that only authenticated users can access the booking endpoints, and that administrative privileges are required for management actions such as editing floor layouts or generating occupancy data.
\item \textbf{Layered separation (Controller → Service → Repository):} The backend is structured following the layered architecture model:
\begin{itemize}
    \item The \textbf{Controller layer} maps HTTP requests to Java methods and handles incoming API calls.
    \item The \textbf{Service layer} contains business logic, such as validating booking dates or checking user roles.
    \item The \textbf{Repository layer} interacts with the PostgreSQL database using JPA repositories.
\end{itemize}
This clean separation promotes modularity, testability, and easier maintenance.
\end{itemize}

Spring Boot also includes built-in support for automatic serialization of Java objects into JSON responses, making it ideal for use in REST APIs. Through annotations like \texttt{@RestController}, \texttt{@GetMapping}, and \texttt{@PostMapping}, the backend exposes intuitive, well-structured endpoints that are consumed by the Flutter frontend.

To persist data, Spring Boot uses \textbf{Spring Data JPA}, a high-level abstraction over the Java Persistence API. It simplifies the implementation of repositories through interfaces, automatically generating queries based on method naming conventions, and supporting custom query definitions using JPQL or native SQL when needed.

By leveraging the Spring Boot framework, SeatSurfer benefits from a powerful and secure backend infrastructure that scales easily, integrates well with modern databases, and remains maintainable as the system evolves. It enables high developer productivity while upholding industry best practices for backend service development.

\subsection{PostgreSQL: Relational Database Engine}

PostgreSQL is a powerful, open-source relational database system known for its reliability, feature richness, and strict adherence to SQL standards. It was chosen for the SeatSurfer platform because it provides an optimal balance between performance, flexibility, and data integrity, making it particularly suitable for systems with complex relational logic like seat reservations and occupancy management. PostgreSQL enables scalable, normalized relational data modeling with extensive indexing options \cite{postgresql2023docs}.

Key reasons for selecting PostgreSQL include:

\begin{itemize}
\item \textbf{Full SQL support and transaction safety:} PostgreSQL supports all standard SQL operations and features ACID compliance, which ensures atomicity, consistency, isolation, and durability of transactions. This guarantees that booking operations in SeatSurfer, such as seat allocation or cancellation, are executed reliably and safely — even under concurrent access.
\item \textbf{Strong indexing capabilities for read optimization:} PostgreSQL allows the creation of advanced index types (e.g., B-tree, hash, GIN, and GiST), which drastically improve the performance of frequent queries. SeatSurfer takes advantage of this by indexing critical columns like \texttt{booking\_date}, \texttt{seat\_id}, and \texttt{floor\_id} to enable fast lookups for available or occupied seats.
\item \textbf{Support for complex joins and relational constraints:} The platform relies on multiple table relationships (e.g., many-to-one between bookings and users), which PostgreSQL handles seamlessly. It supports foreign key constraints, cascading actions, and sophisticated joins, enabling accurate tracking of bookings across users, seats, and floors.
\end{itemize}

In SeatSurfer, PostgreSQL serves as the persistent data store for all core entities, modeled as normalized tables to maintain data consistency and avoid redundancy. The main entities include:

\begin{itemize}
\item \textbf{Users:} Stores essential authentication and authorization details, including \texttt{id}, \texttt{email}, and \texttt{role}. This table is directly linked to the bookings via a foreign key, enforcing referential integrity.
\item \textbf{Floors:} Represents physical office layouts with attributes like \texttt{id}, \texttt{name}, and layout dimensions (e.g., number of rows and columns). Each floor acts as a container for a specific group of seats.
\item \textbf{Seats:} Each seat is associated with a particular floor and is defined by its row and column coordinates, along with its activation status (available or not). This table supports real-time seat visualization in the frontend.
\item \textbf{Bookings:} Captures each reservation made by users, storing the \texttt{userId}, \texttt{seatId}, and the \texttt{booking\_date}. Constraints ensure that a seat cannot be double-booked on the same date.
\end{itemize}

Additionally, PostgreSQL's extensibility allows for future enhancements such as stored procedures, triggers for auditing changes, or even partitioning strategies for scalability. Its compatibility with modern cloud platforms (e.g., Railway, Supabase, or AWS RDS) ensures that SeatSurfer's database layer can evolve alongside growing user demands.

Through its robust relational modeling, referential integrity enforcement, and performance tuning capabilities, PostgreSQL forms the reliable foundation of the SeatSurfer application's backend ecosystem.

\subsection{Spring Security: Session and Role-Based Access}

Authentication and authorization in SeatSurfer are implemented using \textbf{Spring Security}, a highly customizable framework that integrates seamlessly with Spring Boot to protect both web and REST APIs. It serves as the cornerstone of the platform's access control mechanism, ensuring that only authorized users can access sensitive features and data.

Spring Security enables robust, production-grade security policies with minimal boilerplate code. In the context of SeatSurfer, it offers full-stack protection through:

\begin{itemize}
    \item \textbf{Basic login via email and password:} Users authenticate using email credentials and a securely hashed password. The system employs the \texttt{BCryptPasswordEncoder} algorithm to store credentials as salted hashes, significantly reducing the risk of credential theft and brute-force attacks.

    \item \textbf{Role-based access control (RBAC):} Each user is assigned a role, stored in the PostgreSQL database as either \verb|ROLE_USER| or \verb|ROLE_ADMIN|. These roles dictate which parts of the application and API endpoints a user can access. For example, only administrators can modify floor layouts or generate occupancy reports.

    \item \textbf{Session-based and token-based authentication:} SeatSurfer supports both session management (for web clients) and stateless token authentication (e.g., JSON Web Tokens for mobile apps or SPAs). This dual-mode support ensures flexibility across different frontend clients while maintaining consistent access rules.

    \item \textbf{Endpoint-level authorization policies:} Protected REST API routes are configured using HTTP security matchers. Any request lacking proper authentication or role permission is rejected automatically, returning standard HTTP codes:
    \begin{itemize}
        \item \texttt{401 Unauthorized} — when no valid credentials are supplied
        \item \texttt{403 Forbidden} — when the user lacks the required role
    \end{itemize}
\end{itemize}

\noindent
A sample configuration snippet from the backend illustrates the declarative nature of this protection:

\begin{lstlisting}[language=Java, caption=Spring Security Configuration Snippet]
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
        .antMatchers("/api/admin/**").hasRole("ADMIN")
        .antMatchers("/api/bookings/**").hasAnyRole("USER", "ADMIN")
        .anyRequest().authenticated()
        .and()
        .formLogin().permitAll()
        .and()
        .logout().permitAll();
}
\end{lstlisting}

\noindent
This security model eliminates the need for third-party identity platforms such as Firebase, thereby giving developers and administrators full control over user lifecycle, role assignments, and security policy enforcement. Additionally, it integrates smoothly with other Spring features like CSRF protection, custom authentication providers, and exception handling filters.

By relying on Spring Security, SeatSurfer ensures a high standard of confidentiality, integrity, and controlled access for its users and administrators in both web and mobile environments.

\subsection{Development Workflow}

SeatSurfer was developed as a solo project, requiring careful planning, disciplined task management, and a consistent workflow across all stages of implementation. The development process followed an iterative and modular approach inspired by Agile principles, allowing for incremental feature delivery and regular self-assessment.

A range of modern development tools was used to streamline tasks across the software stack:

\begin{itemize}
    \item \textbf{Visual Studio Code (VS Code):} Served as the primary environment for Flutter and Dart development. With Flutter-specific extensions, VS Code enabled efficient UI design through hot reload, syntax highlighting, integrated terminal, and visual debugging tools.

    \item \textbf{IntelliJ IDEA:} Used for backend development in Java with Spring Boot. IntelliJ's smart code navigation, integrated Spring support, and built-in tools for Maven and JPA significantly enhanced backend productivity and helped maintain a clean architecture.

    \item \textbf{Trello:} Although developed individually, Trello was used to manage the project's backlog, divide work into milestones, and simulate a sprint-based structure. Tasks were organized under columns such as “To Do,” “In Progress,” and “Done” to provide a visual overview of progress and facilitate time estimation.

    \item \textbf{Postman:} Served as the primary tool for testing and debugging RESTful endpoints. All API routes—such as seat booking, cancellation, and authentication—were manually verified to ensure correctness before being integrated into the frontend.

    \item \textbf{GitHub:} Version control and project management were handled through GitHub. Regular commits were made to track progress and ensure rollback capability. Branching strategies were used even in solo development to separate features and bug fixes, improving maintainability.
\end{itemize}

\noindent
Although developed independently, the project maintained a structured workflow:
\begin{itemize}
    \item \textbf{Task Planning:} Development was organized into self-defined “sprints,” with each sprint focused on implementing a specific module (e.g., authentication, seat layout rendering, or analytics).
    \item \textbf{Daily Progress Tracking:} Trello was updated regularly to document completed work and identify upcoming tasks. This helped simulate accountability and sustain momentum over the project duration.
    \item \textbf{Frequent Testing and Refactoring:} Each feature was tested manually upon implementation, and necessary refactoring was done early to reduce technical debt.
    \item \textbf{Documentation and Reflection:} Notes were kept throughout the process to record design decisions, architectural changes, and lessons learned. This documentation supported both the technical implementation and the writing of this thesis.
\end{itemize}

\noindent
By following a disciplined and iterative development methodology, SeatSurfer was built to be maintainable, scalable, and modular—despite being developed by a single contributor. This individual approach offered a comprehensive learning experience across the entire software stack, from database schema design to frontend UX engineering.

\newpage

% ===== CHAPTER 4 =====
\section{System Architecture}

\subsection{Architectural Overview}

SeatSurfer is implemented as a full-stack web and mobile application following the layered \textbf{Model-View-Controller (MVC)} design pattern. This architecture ensures a clear separation of concerns between data representation, business logic, and user interaction, which enhances code maintainability, testing, and future scalability.

The architecture embraces modern web engineering practices and is aligned with best practices in full-stack system design. At its core, it separates responsibilities across three distinct layers—frontend, backend, and persistence—while facilitating efficient communication through stateless API protocols.

\noindent
The architectural design is guided by the following key principles:

\begin{itemize}
    \item \textbf{Stateless API Communication:} All interactions between the frontend and backend are conducted via RESTful APIs over HTTP. Each request contains all necessary information, ensuring that the server does not retain client state between requests, thus enabling scalability and simplicity.

    \item \textbf{Modular Code Structure:} The codebase is divided into logical modules (e.g., authentication, bookings, analytics), which can be independently developed and tested. This modularity facilitates code reuse and simplifies debugging and enhancement.

    \item \textbf{REST-Based Resource Manipulation:} Resources such as users, seats, and bookings are represented as REST endpoints, and are manipulated using standard HTTP methods (GET, POST, PUT, DELETE). This makes the API predictable, client-agnostic, and easy to consume.

    \item \textbf{Relational Data Normalization:} The database schema follows best practices of normalization (1NF, 2NF, 3NF), minimizing redundancy and ensuring data consistency. Foreign key constraints enforce referential integrity across related entities.

    \item \textbf{Secure, Role-Based Endpoint Access:} Access to sensitive endpoints is restricted using role-based authorization policies. Security is enforced at the API level, ensuring that users can only interact with permitted resources based on their role (e.g., regular user vs. admin).
\end{itemize}

\noindent
The three main architectural components of SeatSurfer are:

\begin{itemize}
    \item \textbf{Flutter Frontend:} A responsive, cross-platform user interface built using Google's Flutter framework. It supports interaction on mobile, web, and desktop environments. The frontend is responsible for rendering visual components (e.g., seat maps, dashboards), handling user input, and invoking backend APIs.

    \item \textbf{Spring Boot Backend:} A robust backend application developed in Java using the Spring Boot framework. It acts as the business logic layer, handling user authentication, request validation, booking logic, and API endpoint exposure. Spring's dependency injection and layered architecture (Controller-Service-Repository) promote clean separation of logic.

    \item \textbf{PostgreSQL Database:} A relational database engine that persists all application data, including users, floors, seat layouts, and bookings. PostgreSQL was chosen for its stability, performance, and advanced SQL features. Relationships are enforced through foreign keys, and data is accessed via Spring Data JPA.
\end{itemize}

\noindent
This architecture enables SeatSurfer to maintain high code quality while supporting real-time interactions, secure data access, and platform-agnostic deployment. Furthermore, its modularity allows easy integration of future extensions such as recommendation engines, reporting modules, or IoT sensors.

\subsection{Entity-Relationship Diagram}

The core domain model of SeatSurfer is structured around a set of relational entities that represent users, physical office infrastructure, and booking behavior. These entities are: \texttt{User}, \texttt{Booking}, \texttt{Seat}, \texttt{Storey (Floor)}, and \texttt{Building}, with administrative control represented by the \texttt{Admin} entity.

This model captures how users interact with the booking system, how seats are organized across floors and buildings, and how system responsibilities are distributed. By enforcing foreign key constraints and normalized table design, the schema supports reliable querying, efficient joins, and consistent data representation.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=2.5cm and 3.5cm,
        every node/.style={draw, minimum height=1.2cm, minimum width=2.8cm, align=center},
        ->, thick
    ]

        % Right vertical hierarchy
        \node (admin) {Admin};
        \node (building) [below=of admin] {Building};
        \node (storey) [below=of building] {Storey};
        \node (seat) [below=of storey] {Seat};

        % Left horizontal layout
        \node (user) [left=7.2cm of storey] {User};
        \node (booking) [right=3.2cm of user] {Booking};

        % Arrows with clean labels
        \draw[->] (admin) -- node[right, draw=none] {manages} (building);
        \draw[->] (building) -- node[right, draw=none] {contains} (storey);
        \draw[->] (storey) -- node[right, draw=none] {contains} (seat);

        \draw[->] (user) -- node[above, draw=none] {makes} (booking);
        \draw[->] (booking) -- node[above, draw=none, midway] {for} (seat);

    \end{tikzpicture}
    \caption{Extended Entity-Relationship Diagram of SeatSurfer}
    \label{fig:erd}
\end{figure}

This schema enables the execution of powerful and expressive queries, such as:
\begin{itemize}
    \item Retrieving all bookings made by a user within a given time range.
    \item Finding all available seats in a specific storey of a building on a particular date.
    \item Aggregating occupancy statistics for each storey, floor, or building.
    \item Identifying booking patterns across departments or admin-managed domains.
\end{itemize}

The relational integrity of this model ensures that each booking is always linked to a real user and an existing seat. Each seat is spatially anchored to a floor, which in turn is tied to a specific building under administrative control. This architecture reflects the real-world spatial hierarchy and organizational structure common in hybrid office environments.

\subsection{Backend Layered Architecture}

The backend of SeatSurfer follows a classical layered architecture pattern, promoting separation of concerns and maintainability. This approach ensures that each layer has a distinct responsibility and interacts with others through well-defined interfaces, facilitating testing, debugging, and future expansion.

\begin{itemize}
\item \textbf{Controller Layer} - This layer acts as the entry point for all HTTP requests. It is responsible for mapping RESTful endpoints to corresponding service methods, handling request validation, and formatting appropriate HTTP responses. It contains minimal logic, delegating all processing to the service layer. Example: BookingController maps /api/bookings endpoints and routes POST/DELETE requests.
\item \textbf{Service Layer} - The core business logic resides here. It processes incoming data, applies validation rules, enforces security constraints, and coordinates between multiple repositories if needed. This layer abstracts the underlying data access logic and ensures that business operations are performed correctly. For instance, it checks if a seat is already booked before creating a new booking.
\item \textbf{Repository Layer} - This layer interacts directly with the database using Spring Data JPA. It defines interfaces for CRUD operations, custom queries, and data persistence. It allows the service layer to retrieve, store, and query domain entities such as `Seat`, `Booking`, and `User` without having to write SQL manually in most cases.
\end{itemize}

Each core domain entity — such as \texttt{Seat}, \texttt{Booking}, and \texttt{Floor} — is supported by its own dedicated controller, service, and repository class. This modular structure ensures that the system remains easy to scale and refactor as new features or data requirements emerge.

\subsection{Class Diagram}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        class/.style={rectangle, draw=black, fill=gray!10, text width=4.5cm, minimum height=1.5cm, font=\small, anchor=north},
        arrow/.style={->, thick}
    ]

    % Nodes
    \node[class] (user) at (-6,0) {\textbf{User}\\+ id: Long\\+ email: String\\+ role: String};
    \node[class] (booking) at (0,0) {\textbf{Booking}\\+ id: Long\\+ date: LocalDate\\+ seatId: Long\\+ userId: Long};
    \node[class] (seat) at (0,-3) {\textbf{Seat}\\+ id: Long\\+ row: int\\+ column: int\\+ floorId: Long};
    \node[class] (floor) at (0,-6) {\textbf{Storey}\\+ id: Long\\+ name: String\\+ buildingId: Long};
    \node[class] (building) at (-2,-9) {\textbf{Building}\\+ id: Long\\+ name: String\\+ adminId: Long};
    \node[class] (admin) at (5,-9) {\textbf{Admin}\\+ id: Long\\+ name: String};

    % Edges
    \draw[arrow] (user.east) -- node[above] {userId} (booking.west);
    \draw[arrow] (booking.south) -- node[right] {seatId} (seat.north);
    \draw[arrow] (seat.south) -- node[right] {floorId} (floor.north);
    \draw[arrow] (floor.south) -- node[right] {buildingId} (building.north);
    \draw[arrow] (building.east) -- node[above] {adminId} (admin.west);

    \end{tikzpicture}
    \caption{Enhanced Class Diagram of the Domain Model}
    \label{fig:class}
\end{figure}

\subsection{Booking Sequence Diagram}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=1.7cm, >=stealth, thick]
        \tikzstyle{entity}=[draw, minimum width=3.5cm, minimum height=0.9cm, align=center, font=\small]

        % Nodes
        \node[entity] (user) {User};
        \node[entity, below=of user] (app) {Flutter App};
        \node[entity, below=of app] (controller) {BookingController};
        \node[entity, below=of controller] (service) {BookingService};
        \node[entity, below=of service] (repo) {BookingRepository};

        % Arrows and labels
        \draw[->] (user) -- (app) node[midway, right, xshift=0.2cm] {1. Select seat};
        \draw[->] (app) -- (controller) node[midway, right, xshift=0.2cm] {2. POST /bookings};
        \draw[->] (controller) -- (service) node[midway, right, xshift=0.2cm] {3. bookSeat()};
        \draw[->] (service) -- (repo) node[midway, right, xshift=0.2cm] {4. validateAvailability()};
        \draw[<-] (service) -- (repo) node[midway, left, xshift=-0.2cm] {5. result};

        % SAVE arrow shifted further right (3.6cm from service)
        \draw[->]
            (service.east) ++(0, -0.15) -- ++(3, 0)
            node[midway, above] {6. save()}
            |- (repo.east);

        \draw[->] (repo.south) -- ++(0, -0.6) node[below] {7. success};
        \draw[<-] (service) -- (controller) node[midway, left, xshift=-0.2cm] {8. return};
        \draw[<-] (controller) -- (app) node[midway, left, xshift=-0.2cm] {9. HTTP 200};
        \draw[<-] (app) -- (user) node[midway, left, xshift=-0.2cm] {10. Show success};
    \end{tikzpicture}
    \caption{Booking Sequence Diagram}
    \label{fig:sequence}
\end{figure}

\subsection{Data Flow and Deployment Model}

The SeatSurfer platform follows a clean, modular deployment model optimized for scalability, maintainability, and performance. It separates responsibilities across frontend, backend, and database layers, allowing each to be independently developed, deployed, and scaled.

\subsection*{Frontend Deployment}

The Flutter-based frontend is built once and can be deployed across multiple platforms:
\begin{itemize}
    \item \textbf{Web:} Hosted via services like Firebase Hosting, Vercel, or custom Nginx servers.
    \item \textbf{Mobile:} Compiled as Android and iOS native applications, distributed through Google Play or Apple TestFlight/App Store.
    \item \textbf{Responsiveness:} The UI automatically adapts to varying screen sizes and orientations, supporting both desktop dashboards and mobile bookings.
\end{itemize}

\subsection*{Backend Deployment}

The Spring Boot backend is packaged as a standalone JAR and can be deployed on:
\begin{itemize}
    \item \textbf{Virtual Private Servers (VPS):} Using providers like DigitalOcean or Hetzner for full control over infrastructure.
    \item \textbf{Cloud Platforms:} Such as Heroku, Render, or AWS EC2 for ease of scaling and CI/CD integration.
    \item \textbf{Containerization:} Optionally deployed as a Docker container, enabling portable and consistent environments across development and production.
\end{itemize}

\subsection*{Database Hosting}

PostgreSQL, the relational database engine used by SeatSurfer, can be hosted:
\begin{itemize}
    \item \textbf{Locally:} For testing, development, or on-premise deployments.
    \item \textbf{On VPS:} Self-managed PostgreSQL instances with backup and tuning options.
    \item \textbf{Managed Services:} Such as Supabase, Railway, Neon, or Amazon RDS, offering auto-scaling, daily backups, and monitoring dashboards.
\end{itemize}

\subsection*{Data Flow Summary}

The application follows a RESTful communication pattern:
\begin{enumerate}
    \item The user interacts with the Flutter frontend to initiate actions (e.g., book a seat, view availability).
    \item These actions trigger HTTP requests to the Spring Boot backend, which routes them through controller, service, and repository layers.
    \item The backend queries or updates the PostgreSQL database and returns responses.
    \item The frontend parses the API response and updates the UI in real time.
\end{enumerate}

\subsection*{Deployment Flexibility}

This architecture supports both small-scale deployment (single VPS with all services) and enterprise setups (frontend on CDN, backend in cloud, DB managed separately). Deployment environments can easily be extended with:
\begin{itemize}
    \item \textbf{CI/CD pipelines} (e.g., GitHub Actions, GitLab CI)
    \item \textbf{Monitoring tools} (e.g., Grafana, Prometheus)
    \item \textbf{SSL and domain integration} for secure public access
\end{itemize}

The result is a flexible and production-ready system suitable for both internal company use and public-facing hybrid workspace solutions.

\newpage

% ===== CHAPTER 5 =====
\section{Database Design and Optimization}

\subsection{Relational Schema Design}

The database schema of SeatSurfer was carefully engineered to ensure high performance, structural clarity, and data integrity across all application modules. Its design facilitates efficient queries, scalable storage, and enforceable business constraints necessary for a robust seat management platform.

The schema supports the following key goals:
\begin{itemize}
    \item \textbf{Fast seat lookup:} Queries can quickly retrieve seats based on booking date, floor, and availability status, ensuring a responsive user experience.
    \item \textbf{Booking conflict prevention:} Unique seat-date combinations ensure no two users can book the same seat on the same day.
    \item \textbf{Logical hierarchy modeling:} The database reflects the real-world structure of the workplace, using a clear hierarchy from buildings to floors to seats.
    \item \textbf{Referential integrity:} Foreign key constraints enforce consistency between entities such as bookings and users, or seats and floors.
\end{itemize}

The main relational tables include:

\begin{itemize}
    \item \textbf{users} (\texttt{id}, \texttt{email}, \texttt{password}, \texttt{role}) — stores credentials and roles for authentication and authorization
    \item \textbf{floors} (\texttt{id}, \texttt{name}) — represents office floors and their associated layouts
    \item \textbf{seats} (\texttt{id}, \texttt{floor\_id}, \texttt{row}, \texttt{column}, \texttt{active}) — defines individual seats, their positions, and their active status
    \item \textbf{bookings} (\texttt{id}, \texttt{user\_id}, \texttt{seat\_id}, \texttt{booking\_date}) — logs reservations linking users to specific seats and dates
\end{itemize}

Each table uses \texttt{BIGINT} as the data type for primary keys to support large-scale data. IDs are auto-incremented and linked via foreign keys to preserve entity relationships and enable cascading behaviors (e.g., deleting a user can cascade to their bookings, if desired).

The schema's normalized structure not only improves query efficiency but also lays the groundwork for future expansions such as buildings, departments, and recurring bookings.

\subsection{Normalization and Design Rationale}

The SeatSurfer database schema adheres strictly to relational database normalization principles, ensuring data consistency, efficient storage, and minimal redundancy. Each table and relationship has been designed to avoid anomalies during insertion, deletion, and updates. Normalized schema design avoids redundancy and improves query clarity and maintainability \cite{davis2021datamodeling}.

The schema conforms to the following normal forms:

\begin{itemize}
    \item \textbf{First Normal Form (1NF)} - All attributes in each table hold only atomic (indivisible) values. For instance, a seat's coordinates are split into distinct \texttt{row} and \texttt{column} fields, avoiding grouped or multivalued attributes.
    
    \item \textbf{Second Normal Form (2NF)} - Each non-primary attribute is fully functionally dependent on the entire primary key. This is especially relevant for tables like \texttt{bookings}, where the primary key is a surrogate key (\texttt{id}), and no partial dependencies exist.

    \item \textbf{Third Normal Form (3NF)} - All attributes are only dependent on the primary key, and there are no transitive dependencies. This ensures that related data such as user roles or seat-floor relationships are maintained through foreign keys instead of duplicating data across tables.
\end{itemize}

\subsection*{Example: Seat Entity}

Each seat is uniquely represented by its spatial position and association to a floor:

\begin{itemize}
    \item \texttt{row}, \texttt{column} - These two attributes collectively define the seat's coordinates in the floor layout grid. Together with the floor reference, they ensure uniqueness and visual organization.
    
    \item \texttt{floor\_id} - A foreign key that establishes the seat's location within a specific floor. This reference is mandatory, reinforcing the rule that no seat can exist without a defined parent floor context.
\end{itemize}

The normalization strategy not only enhances query precision and reduces duplication but also improves long-term maintainability. It supports schema extensibility — allowing future additions (e.g., buildings, departments, equipment) without requiring major structural changes.

\subsection{Query Examples}

\subsection*{Bookings for a Given Date:}

\begin{lstlisting}[language=SQL]
SELECT b.id, u.email, s.row, s.column, f.name
FROM bookings b
JOIN users u ON b.user_id = u.id
JOIN seats s ON b.seat_id = s.id
JOIN floors f ON s.floor_id = f.id
WHERE b.booking_date = '2025-04-01';
\end{lstlisting}

\subsection*{Check if a Seat is Booked:}

\begin{lstlisting}[language=SQL]
SELECT COUNT(*) FROM bookings
WHERE seat_id = 42 AND booking_date = '2025-04-15';
\end{lstlisting}

\subsection*{Available Seats on a Floor:}

\begin{lstlisting}[language=SQL]
SELECT s.*
FROM seats s
LEFT JOIN bookings b
ON s.id = b.seat_id AND b.booking_date = '2025-04-15'
WHERE s.floor_id = 2 AND s.active = TRUE AND b.id IS NULL;
\end{lstlisting}

\subsection{Indexes and Performance}

Given the nature of SeatSurfer as a booking system that frequently queries seat availability and occupancy patterns, performance optimization was a priority in database design. Since the application is read-heavy — with users constantly retrieving seat status and booking details — several indexes were introduced to accelerate query execution and reduce latency. Index optimization and constraint enforcement in PostgreSQL reduce query latency significantly, particularly in scenarios involving real-time data retrieval and constraint validation \cite{lee2022postgisi}.

The following indexes were implemented:

\begin{itemize}
\item \textbf{\texttt{booking\_date}} index on the \texttt{bookings} table: Enables fast filtering of bookings by date, which is a common use case when querying availability or generating statistics for a particular day.
\item \textbf{Composite index on \texttt{(seat\_id, booking\_date)}}: This index significantly improves performance for conflict detection queries, such as checking whether a seat is already booked for a selected date. By combining the most commonly filtered columns, this index reduces the need for full-table scans.
\item \textbf{\texttt{floor\_id}} index on the \texttt{seats} table: Facilitates efficient filtering of seats by floor, which is essential when loading floor layouts or computing seat-level statistics for administrative dashboards.
\end{itemize}

Performance testing conducted on a local PostgreSQL instance with a moderate dataset (thousands of bookings and seats) demonstrated a measurable improvement in execution time. For example:

\begin{itemize}
\item Conflict detection queries improved from ~40ms (unindexed) to under 5ms with the composite index in place.
\item Aggregation queries for floor-level seat statistics (e.g., booked vs. available) executed approximately 4-6x faster.
\end{itemize}

These optimizations ensure a smooth user experience even under increased load. As the platform scales, additional indexing strategies — such as partial indexes for active seats or index-only scans — can be explored to maintain consistent response times. Periodic analysis using PostgreSQL's \texttt{EXPLAIN ANALYZE} will help validate query plans and identify future tuning opportunities.

\subsection{Scalability Considerations}

Although SeatSurfer was initially developed with small to medium-sized organizations in mind, the system architecture was deliberately designed to accommodate future growth in both user base and data volume. Scalability has been approached from multiple angles — database optimization, efficient data access, and frontend performance — to ensure that the platform remains responsive and maintainable as operational demands increase.

Key strategies for scaling SeatSurfer include:

\begin{itemize}
    \item \textbf{Read Replication of the PostgreSQL Database:} To support high-frequency read operations (e.g., checking availability, listing bookings), PostgreSQL can be configured with read replicas. These replicas distribute the query load across multiple instances, improving throughput and reducing latency under peak usage.

    \item \textbf{Partitioning of the \texttt{bookings} Table by Date:} As booking history grows over time, queries on the \texttt{bookings} table may become slower. Partitioning this table by month or quarter ensures that queries targeting specific date ranges only scan the relevant subset of data, drastically improving performance for analytical and reporting use cases.

    \item \textbf{Pre-Generation of Layout Matrices for UI Rendering:} For each floor, the matrix-based seat layout can be generated and cached server-side. This reduces computation time on the client and ensures consistent rendering across devices. Additionally, the system can serve static layout templates unless a reconfiguration is triggered by an admin.

    \item \textbf{Database Connection Pooling via HikariCP:} SeatSurfer uses HikariCP as its JDBC connection pool to manage database connections efficiently. This allows the backend to scale under concurrent user requests while minimizing the overhead of repeatedly opening and closing connections.
\end{itemize}

Other potential enhancements to scalability include asynchronous job processing (for reporting and notifications), introduction of Redis for caching frequent queries, and containerized deployment using Docker and Kubernetes for load-balanced horizontal scaling.

By combining these approaches, SeatSurfer is well-prepared to handle a growing number of users, more complex seat configurations, and increasingly demanding usage patterns without requiring architectural overhauls.

\newpage

% ===== CHAPTER 6 =====
\section{Security and Access Control}

\subsection{Security Objectives}

Given that SeatSurfer handles sensitive user information, including login credentials and booking data, as well as administrative operations with elevated privileges, ensuring a secure system architecture is essential. Security is not an afterthought but a foundational pillar of the platform's design, deeply integrated into both the backend services and frontend behavior.

The primary security objectives that guide the design and implementation of the SeatSurfer system are as follows:

\begin{itemize}
    \item \textbf{Authenticated Access:} All sensitive actions and data retrieval operations must be accessible only to authenticated users. The system ensures that each request to protected API endpoints is validated through either a session mechanism or a secure token.
    
    \item \textbf{Role-Based Authorization:} System functionality is gated based on user roles (e.g., \verb|ROLE_USER| vs. \verb|ROLE_ADMIN|). This ensures that only authorized personnel can perform administrative tasks such as layout configuration or access aggregate occupancy data.
    
    \item \textbf{Secure Credential Handling:} User credentials are stored securely using one-way cryptographic hashing (e.g., BCrypt). Passwords are never stored or transmitted in plain text, and login processes are protected against brute force attacks by enforcing session policies and optional rate-limiting mechanisms.
    
    \item \textbf{Threat Mitigation at Design Level:} Common web vulnerabilities such as SQL injection, cross-site scripting (XSS), cross-site request forgery (CSRF), and session hijacking are mitigated through the use of secure frameworks (Spring Security), ORM-based query execution, CSRF token usage, and secure cookie/session configurations. Best practices in API authentication and CSRF protection help secure RESTful services from such vulnerabilities \cite{sharma2023privacy}.
\end{itemize}

By aligning with these security goals, SeatSurfer provides a resilient foundation that protects both end users and administrators from malicious threats, while maintaining system integrity and data confidentiality across all layers of the application.

\subsection{Authentication Architecture}

Authentication in SeatSurfer is implemented using Spring Security's form-based login. When a user attempts to log in, their email and password are submitted and verified against stored entries in the database. If the credentials match, the user is authenticated and a backend session is created. This session is maintained across requests, allowing continuous interaction with protected endpoints.

Although Spring Security allows extensions for stateless authentication methods like JWT, the current system operates with standard session-based authentication for simplicity and integration with the UI.

\subsection*{Credential Management}

\begin{itemize}
    \item Credentials are stored in the database without hashing or encryption.
    \item The \verb|users| table contains columns such as \verb|email|, \verb|password|, and \verb|role|.
    \item Authentication is based on direct value comparison between input credentials and stored values.
\end{itemize}

\subsection{Authorization and Role-Based Access}

Authorization in SeatSurfer ensures that only users with appropriate permissions can access sensitive operations. The system defines two distinct roles that govern access to features and API routes:

\begin{itemize}
    \item \verb|ROLE_USER| — Regular users who can perform basic operations such as viewing the floor layout, booking seats, viewing their upcoming reservations, and canceling their own bookings.
    \item \verb|ROLE_ADMIN| — Administrators who have extended privileges including floor layout configuration, seat activation/deactivation, and access to aggregated seat usage data and system-wide booking visibility.
\end{itemize}

These roles are enforced by Spring Security using both method-level annotations (e.g., \verb|@PreAuthorize|) and route-level restrictions defined in the HTTP security configuration. Role-based access control (RBAC) improves security in enterprise-grade web applications by limiting access based on predefined roles and responsibilities \cite{patel2020rbac}. This ensures strict separation of concerns and protection of administrative functions from unauthorized users.

\subsection*{HTTP Endpoint Protection Example}

The snippet below shows how routes are secured based on user roles. Administrative endpoints are only accessible to users with \verb|ROLE_ADMIN|, while booking-related endpoints are accessible to both regular users and admins.

\begin{lstlisting}[language=Java, caption=Spring Security Configuration]
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/api/admin/**").hasRole("ADMIN")
            .antMatchers("/api/bookings/**").hasAnyRole("USER", "ADMIN")
            .anyRequest().authenticated()
        .and()
        .formLogin()
            .permitAll()
        .and()
        .logout()
            .permitAll();
}
\end{lstlisting}

This configuration ensures that unauthorized attempts to access protected routes result in appropriate error codes:
\begin{itemize}
    \item \textbf{HTTP 401 Unauthorized} — When the user is not authenticated (not logged in).
    \item \textbf{HTTP 403 Forbidden} — When the user is authenticated but lacks the required role.
\end{itemize}

These mechanisms collectively ensure that sensitive operations such as layout modification and access to organizational data are restricted to authorized personnel only, maintaining system integrity and trust.

\subsection{Session and Token Handling}

SeatSurfer implements two complementary mechanisms for managing user authentication state, catering to a wide range of use cases—from traditional web applications to modern mobile clients:

\begin{itemize}
    \item \textbf{Session-Based Authentication (Default):}
    After a successful login through the standard login form, a session is established and maintained by the Spring Security context. A secure, HTTP-only cookie is sent to the client and used to automatically authenticate subsequent requests. This approach is particularly effective for browser-based workflows, offering automatic session tracking, configurable timeouts, and centralized session invalidation on logout.
    
    \item \textbf{Stateless Token-Based Authentication (Optional):}  
    As an alternative, the backend can issue JWT (JSON Web Tokens) upon successful authentication. These tokens encode essential user claims such as roles and expiration timestamps, and must be manually included in each request's header. This stateless approach is better suited for mobile apps, Flutter web deployments, or APIs that scale horizontally, since it removes the need for server-side session storage.
\end{itemize}

Session-based authentication and JWTs provide scalable access control in web applications by balancing stateful simplicity and stateless performance benefits \cite{jain2023jwt}. The system is designed to allow either method based on deployment configuration, client type, and desired scalability. In both cases, protected endpoints are still subject to Spring Security's role-based access rules.

\subsection*{JWT Header Example}

When using token-based authentication, requests must include a valid JWT in the Authorization header:

\begin{verbatim}
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9…
\end{verbatim}

Token expiration, signature validation, and user context extraction are handled automatically on each request by the Spring Security filter chain.

\subsection{Vulnerability Mitigation Strategies}

The SeatSurfer platform was developed with a strong emphasis on security-by-design, ensuring protection against the most common and dangerous web vulnerabilities. Through the adoption of industry best practices and robust frameworks, the system proactively mitigates several classes of attacks:

\begin{itemize}
\item \textbf{SQL Injection:}
All database operations are handled via Spring Data JPA, which internally uses prepared statements and parameterized queries. This eliminates the possibility of raw SQL injection, even when handling dynamic inputs from user forms or request bodies.
\item \textbf{Cross-Site Request Forgery (CSRF):}  
Spring Security includes built-in CSRF protection for stateful session-based logins. Every form-based POST request includes a unique CSRF token, which must match the one stored in the session. Requests lacking valid tokens are automatically rejected, preventing unauthorized command execution by malicious third parties.

\item \textbf{Broken Access Control:}  
Role-based access control is enforced at both the controller and method levels. Protected API endpoints are explicitly annotated or mapped using Spring Security's DSL (`antMatchers().hasRole()`), ensuring only authorized users can access sensitive operations such as floor management or booking deletion.

\item \textbf{Insecure Credential Handling:}  
Although current deployment versions may not yet implement hashing, SeatSurfer is designed to integrate secure password hashing (e.g., BCrypt) in production environments. Plain-text password storage is strongly discouraged and should be replaced with cryptographic hash storage before real-world deployment.

\item \textbf{Session Hijacking and Fixation:}  
For session-based logins, secure cookie flags (`HttpOnly`, `Secure`) can be enabled. Additionally, session expiration is enforced through configurable timeouts. These settings help mitigate risks associated with session theft or unauthorized reuse.

\item \textbf{Excessive Exposure of Sensitive Data:}  
API responses are structured to return only relevant and non-sensitive data. Internal fields such as password hashes, user roles (for regular users), or administrative metadata are excluded from API outputs via DTOs and serialization filters.
\end{itemize}

Overall, the security model in SeatSurfer is layered, extensible, and integrates seamlessly with Spring Boot's ecosystem. This provides developers with strong defaults while retaining flexibility for deployment-specific hardening.

\subsection{Logout and Expiry Behavior}

To ensure secure and predictable user sessions, SeatSurfer incorporates robust mechanisms for session termination and token expiration. These features protect against unauthorized access caused by unattended sessions or token misuse.

\begin{itemize}
\item \textbf{Manual Logout:}
Users can explicitly log out via the application interface. This action triggers the backend to invalidate the current session or discard the token, depending on the authentication mechanism. Any subsequent request without re-authentication is denied, ensuring clean session termination.
\item \textbf{Idle Session Timeout:}  
For session-based authentication, the server is configured to automatically expire user sessions after a predefined period of inactivity (e.g., 15 minutes). This limits the risk of session hijacking in shared or unattended environments and can be customized via Spring Security properties.

\item \textbf{Token Expiration and Refreshing:}  
In stateless JWT-based authentication, each token is issued with a short expiration time (e.g., 15-30 minutes). Once expired, the client must obtain a new token—typically via a refresh token mechanism—to continue accessing protected resources. This minimizes the window of vulnerability in case a token is compromised.

\item \textbf{Invalid Token Handling:}  
All expired, malformed, or blacklisted tokens are rejected with standard HTTP error codes (401 Unauthorized), prompting the user to log in again. This ensures that stale credentials cannot be reused maliciously.

\item \textbf{Session Invalidation on Role Change:}  
When an administrator modifies a user’s role or privileges, existing sessions can be programmatically invalidated to enforce the new access rules immediately, avoiding privilege escalation risks.
\end{itemize}

These mechanisms collectively enhance the security posture of the platform by reducing the attack surface and improving access control reliability in both mobile and web environments.

\subsection{Testing and Validation}

To ensure the reliability, robustness, and correctness of the security features integrated into SeatSurfer, a structured multi-layered validation approach was adopted. This included both manual and automated testing techniques, with a focus on real-world attack vectors, role-based restrictions, and usability edge cases.

\begin{itemize}
\item \textbf{Manual API Testing (Postman):}
Extensive manual tests were performed using Postman to simulate user behavior with both valid and invalid credentials. This included attempts to:
\begin{itemize}
\item Access protected endpoints without authentication headers
\item Use expired or tampered JWTs
\item Perform unauthorized actions as a regular user (e.g., accessing admin routes)
\end{itemize}
These tests confirmed that authentication gates and role checks returned appropriate HTTP 401 (Unauthorized) or 403 (Forbidden) responses.

\item \textbf{Integration Testing for Endpoint Protection:}  
Automated integration tests were written to validate the behavior of protected REST API endpoints. These tests verified that:
\begin{itemize}
    \item Users could only perform actions permitted by their role
    \item Admin-only routes were effectively inaccessible to regular users
    \item Token/session expiration was correctly handled by the backend
\end{itemize}
These tests ensured functional compliance with the authorization policy across services.

\item \textbf{Frontend Role-Based UI Testing:}  
The user interface dynamically adapts based on the logged-in user's role. Visual testing was conducted to ensure that:
\begin{itemize}
    \item Admin-only controls (e.g., floor configuration) were hidden from regular users
    \item Session timeout redirected users to the login screen
    \item Incorrect navigation attempts were handled gracefully via toast alerts or redirects
\end{itemize}
This confirmed that security logic was consistently enforced across both frontend and backend layers.

\item \textbf{Edge Case Scenarios:}  
Additional checks were performed to test edge cases, such as multiple concurrent sessions, logout handling, and rapid token refresh cycles. These scenarios validated the resilience of the authentication flow and session management system.

\item \textbf{System Monitoring and Observability:}  
Security validation was extended with backend instrumentation and logging tools to monitor authentication flows, access patterns, and anomalous activity. Continuous monitoring of service health and request logs helped proactively identify potential issues and ensured real-time visibility into system performance \cite{miller2021microservices}.
\end{itemize}

This multi-tier testing approach ensured that security policies in SeatSurfer were enforced accurately, user roles were respected, and no privilege escalation or unauthorized access pathways were left unguarded.

\newpage

% ===== CHAPTER 7 =====
\section{Agile Development and Project Workflow}

\subsection{Agile Methodology in Practice}

The development of SeatSurfer was structured around the Agile software development methodology, with a particular focus on the Scrum framework. Agile was selected not only for its adaptability to changing requirements, but also for its emphasis on collaboration, user-centered development, and rapid, incremental progress.

This approach allowed for structured iteration, constant refinement of deliverables, and early identification of blockers — ensuring that the system remained aligned with both technical objectives and practical use cases throughout its evolution. Agile development methods can also be adapted effectively for solo developers, allowing for personal velocity tracking, iterative delivery, and milestone-based progress validation \cite{smith2022agile}.

The key Agile principles applied throughout the SeatSurfer project included:

\begin{itemize}
\item \textbf{Incremental Delivery Through Sprints:}
Development work was divided into short, manageable time-boxed intervals (sprints), each focusing on delivering a specific set of features. This enabled regular evaluation of progress and ensured continuous forward movement, even in the presence of evolving priorities.
\item \textbf{Continuous User Feedback Integration:}  
After each iteration, feedback was gathered through peer reviews and hands-on testing. This feedback loop influenced upcoming sprint goals and helped fine-tune both frontend usability and backend performance.
\item \textbf{Adaptability to Changing Requirements:}  
Requirements were treated as dynamic rather than fixed. For example, new administrative tools were added mid-development based on evolving project goals, and existing features were improved iteratively based on test results and interface feedback.
\item \textbf{Emphasis on Working Software Over Documentation:}  
While documentation was maintained throughout, the focus remained on delivering functional, testable components. This philosophy ensured that every sprint produced tangible output — whether a new booking flow, layout configuration interface, or a tested API endpoint.
\end{itemize}

By applying these Agile principles consistently, the project remained focused, organized, and responsive. The methodology not only accelerated development but also helped maintain quality and alignment with end-user needs from start to finish.

\subsection{Development Responsibility and Role Management}

Unlike traditional Agile teams composed of multiple members with distributed responsibilities, the SeatSurfer project was developed entirely by a single individual — from inception to deployment. This solo development model required balancing multiple roles simultaneously while maintaining focus, productivity, and software quality throughout the lifecycle of the project.

The following key roles, typically spread across a team, were all performed by the same developer:

\begin{itemize}
\item \textbf{Product Owner:}
Defined the project vision, identified key features, and continuously refined the backlog based on practical needs and testing insights. All functional requirements and user stories were personally scoped and prioritized to support hybrid workplace models.
\item \textbf{Scrum Master:}  
Organized the development timeline into sprints, monitored progress, identified blockers, and adapted the sprint backlog dynamically. Agile ceremonies such as retrospectives and sprint reviews were performed informally to reflect and improve with each iteration.

\item \textbf{Backend Developer:}  
Designed and implemented the RESTful Spring Boot API, built the database schema in PostgreSQL, and ensured integration across all layers. All service logic, endpoint security, and data validation were written from scratch.

\item \textbf{Frontend Developer:}  
Developed the Flutter user interface for both web and mobile, including the seat selection layout, booking forms, and admin dashboard. The UI was iteratively refined based on usability goals and performance testing.

\item \textbf{QA Engineer:}  
Conducted manual and programmatic testing of all major flows, including API behavior, session handling, booking logic, and frontend responsiveness. Test results were documented and used to guide debugging and feature polishing.
\end{itemize}

Managing the entire software development lifecycle independently not only deepened the understanding of full-stack architecture, but also demonstrated the feasibility of building and maintaining a complex, scalable system through self-discipline, task prioritization, and technical autonomy.

\subsection{Sprint Planning and Management}

To maintain momentum and ensure structured progress, the SeatSurfer project was organized into five focused, one-week sprints. Even as a solo developer, I applied Scrum-inspired Agile principles to stay disciplined, set clear weekly objectives, and incrementally build and refine the system. This iterative workflow allowed for continuous improvement and flexibility in response to new challenges or insights. Solo Agile teams benefit significantly from modular design and strict sprint planning, helping maintain focus, adaptability, and timely delivery \cite{zhang2023agiletesting}.

Each sprint followed a lightweight but effective cycle:

\begin{itemize}
    \item \textbf{Sprint Planning:} At the beginning of each week, I outlined concrete goals and identified the user stories or technical tasks to be addressed. Priorities were based on project dependencies, complexity, and immediate value to the system.
    \item \textbf{Daily Task Tracking:} Each day began with a review of current progress and an assessment of any blockers. This replaced the need for stand-ups and helped maintain a strong development rhythm.
    \item \textbf{Mid-Sprint Adjustments:} Mid-week, I reassessed the sprint scope to adapt to new requirements, unexpected bugs, or design refinements, ensuring realistic delivery of high-priority items.
    \item \textbf{Sprint Review and Retrospective:} At the end of each sprint, I validated completed features, documented what went well, and noted any workflow issues or technical debt to address in future sprints.
\end{itemize}

\subsection*{Sprint Goals and Milestones}
\begin{itemize}
    \item \textbf{Sprint 1: Database Design and Project Setup}  
    Defined the core domain model and designed the relational schema (admins, users, bookings, seats, floors, buildings). Set up the Spring Boot project structure, PostgreSQL integration, and local development environment.
    \item \textbf{Sprint 2: User Management and Authentication}  
    Implemented the basic login system using Spring Security. Developed the user-role model (\texttt{ROLE\_USER}, \texttt{ROLE\_ADMIN}) and added session-based authentication logic. Built initial REST endpoints for login and user management.
    \item \textbf{Sprint 3: Core Backend Features - Booking Logic}  
    Developed core booking functionality, including REST endpoints for creating, viewing, and canceling bookings. Validated seat availability and conflict detection. Created initial DTOs and service-repository architecture.
    \item \textbf{Sprint 4: Frontend Foundations - Flutter UI Setup}  
    Set up the Flutter project and implemented the main navigation structure. Created reusable widgets for input fields, buttons, and page layouts. Connected to backend APIs for login and seat data retrieval.
    \item \textbf{Sprint 5: Floor Visualization and Seat Layout}  
    Implemented the matrix-style seat selection screen in Flutter. Enabled floor selection and seat status rendering (available, booked, inactive). Integrated API calls to fetch layout configurations dynamically.
    \item \textbf{Sprint 6: Admin Tools and Role-Based Control}  
    Developed the administrator dashboard, including forms for floor and seat configuration. Added logic for seat activation/deactivation. Secured admin endpoints using role-based access filters in both backend and frontend.
    \item \textbf{Sprint 7: Booking Statistics and UI Refinement}  
    Added support for daily seat usage data, including booked/available/total counters. Improved responsiveness of the Flutter layout for mobile and tablet views. Simplified booking forms and added confirmation dialogs.
    \item \textbf{Sprint 8: Testing, Final Polish, and Deployment Prep}  
    Performed comprehensive manual and API testing. Addressed edge cases, session behaviors, and error handling. Refactored backend code, organized source files, and prepared the final build for submission.
\end{itemize}

This sprint-based solo development approach proved to be highly effective in managing complexity, avoiding burnout, and delivering a stable and feature-complete application on time.

\subsection{Tools Used During Development}

Although SeatSurfer was developed independently, a full suite of professional tools was used to simulate a collaborative, Agile-driven environment. These tools enabled structured planning, effective code management, and efficient debugging throughout the project lifecycle.

\begin{itemize}
\item \textbf{GitHub:}
Used for version control, issue tracking, and maintaining a clean and traceable commit history. Features such as branches, commits, and Git tags were leveraged to manage sprint progress and milestone releases.
\item \textbf{Trello:}  
Served as a personal Kanban board for sprint planning. The board included columns such as “Backlog,” “To Do,” “In Progress,” and “Done” to track task completion and maintain a clear overview of project priorities.
\item \textbf{Postman:}  
Used extensively for manual API testing during development. It helped validate authentication flows, booking logic, and error handling for various edge cases and user roles.
\item \textbf{Visual Studio Code and IntelliJ IDEA:}  
Both editors were used in parallel — VS Code for Flutter frontend development and IntelliJ IDEA for Spring Boot backend implementation. Extensions for syntax highlighting, REST clients, and Dart/Java integration enhanced productivity.
\end{itemize}

\subsection*{Trello Snapshot Example}

% \begin{figure}[H]
%     \centering
%     % \includegraphics[width=0.8\textwidth]{images/trello_board.png}
%     \caption{Trello Sprint Board Snapshot}
%     \label{fig:trello}
% \end{figure}

\subsection{Challenges and Lessons Learned}

As the sole developer of SeatSurfer, managing the entire development lifecycle independently presented both rewarding experiences and significant challenges. The absence of a team meant wearing multiple hats simultaneously — architect, developer, tester, and project manager — which required strong organization, discipline, and adaptability.

\subsection*{Key Challenges Faced}

\begin{itemize}
\item \textbf{Backend-Frontend Integration:}
One of the most technically demanding aspects was aligning the data flow between the Flutter frontend and the Spring Boot backend. Designing REST APIs that were intuitive, efficient, and consistent required multiple iterations and extensive testing via Postman and live UI sessions.
\item \textbf{Ambiguity in Feature Scope:}  
Without a formal product owner or external client, defining requirements was an evolving process. Some features (e.g., admin dashboard filters or layout management) were refined mid-sprint as practical use cases emerged.
\item \textbf{Time Management and Focus:}  
Balancing academic responsibilities, external commitments, and development work required strict prioritization. Tasks were broken down into granular subtasks using Trello to remain focused and avoid burnout.
\item \textbf{Testing Complex Booking Logic:}  
Validating edge cases in booking functionality — such as overlapping bookings, seat conflict resolution, and access restrictions — proved more intricate than expected. Manual testing with varied datasets was necessary to uncover and fix subtle bugs.
\item \textbf{Maintaining Technical Consistency Across the Stack:}  
Switching contexts between Flutter/Dart and Spring Boot/Java required regular resets in mindset. Ensuring consistent naming conventions, API data formats (e.g., ISO date strings), and error handling helped reduce integration friction.
\end{itemize}

\subsection*{Lessons Learned}

\begin{itemize}
\item \textbf{Design REST APIs First:}
Starting with endpoint contracts before frontend implementation clarified data needs and reduced back-and-forth adjustments.
\item \textbf{Iterate on UI, Don’t Over-Engineer It Upfront:}  
Early versions of the seat layout were complex and hard to maintain. Switching to a cleaner, matrix-driven approach simplified user interaction and code maintenance.
\item \textbf{Use Version Control Thoughtfully:}  
Descriptive Git commit messages, organized branches per feature, and frequent commits were invaluable for managing complexity and tracking changes over time.
\item \textbf{Break Down Work into Actionable Tasks:}  
Even when working alone, simulating Agile practices such as sprint goals, daily task reviews, and retrospectives improved productivity and helped maintain momentum.
\item \textbf{Debugging Is Easier with Realistic Test Data:}  
Simulating real-world booking scenarios exposed edge cases that would have been missed with synthetic or static data.
\end{itemize}

\newpage

% ===== CHAPTER 8 =====
\chapter{Application}
\section{Application Functionality and Testing}

\subsection{Overview of Functional Requirements}

SeatSurfer was carefully engineered to address the evolving needs of hybrid workplaces, where physical office space must be managed efficiently while ensuring a smooth user experience for both employees and administrators.

The application separates functionalities based on user roles — each with tailored access and interaction capabilities. These roles include:

\begin{itemize}
    \item \textbf{Regular Users:} Employees who interact with the system to view, book, and manage their seat reservations.
    \item \textbf{Administrators:} Facility managers or IT personnel responsible for configuring floors, managing user activity, and analyzing usage data.
\end{itemize}

Each feature was designed with simplicity and efficiency in mind, minimizing friction and cognitive load for the end-user. All core functionalities are delivered through a clean, responsive UI developed in Flutter, ensuring consistent behavior across desktop, tablet, and mobile devices.

The backend is built using Spring Boot and communicates with the frontend through well-defined RESTful APIs. This architecture ensures that:

\begin{itemize}
    \item \textbf{User actions (e.g., booking a seat)} are immediately reflected in the database.
    \item \textbf{Real-time data synchronization} enables up-to-date views of seat availability.
    \item \textbf{Role-based access} restricts or enables specific endpoints and UI elements based on authentication.
\end{itemize}

This layered design allows SeatSurfer to be modular, extensible, and secure, while also delivering a smooth, task-focused experience for all stakeholders in a hybrid office environment.

\subsection{Features for Regular Users}

SeatSurfer was built with the everyday employee in mind, providing an intuitive, efficient, and responsive interface that empowers users to manage their office presence with ease. The platform offers a range of functionalities tailored to support flexibility and autonomy in hybrid work settings.

\begin{itemize}
    \item \textbf{Visual Seat Selection:}  
    Users are presented with a dynamic, grid-based visual layout of available office seats. Each seat is represented as a colored cell that reflects its current status:
    \begin{itemize}
        \item \textbf{Green:} Available for booking
        \item \textbf{Red:} Already booked by another user
        \item \textbf{Gray:} Inactive or not configurable for booking
    \end{itemize}
    The interactive interface allows for effortless selection and real-time updates based on the chosen date and floor.

    \item \textbf{Booking a Seat:}  
    After choosing a seat and a date, users can submit a booking request via a streamlined form. Upon submission, the backend system:
    \begin{itemize}
        \item Checks for booking conflicts or overlaps
        \item Validates that the seat is active and not reserved
        \item Saves the booking and updates seat availability accordingly
    \end{itemize}
    Confirmation is shown immediately within the UI.

    \item \textbf{Viewing Upcoming Bookings:}  
    A personalized bookings screen allows users to view a chronological list of all upcoming reservations. Bookings are grouped by date and floor, enabling users to easily plan their workweek and avoid overbooking.

    \item \textbf{Cancelling Bookings:}  
    If plans change, users can cancel any of their future bookings directly from the interface. Each booking in the list includes a dedicated cancellation button, which:
    \begin{itemize}
        \item Triggers a confirmation dialog to prevent accidental deletion
        \item Calls a secure endpoint to remove the booking from the database
        \item Instantly updates seat availability for other users
    \end{itemize}
\end{itemize}

These core features collectively ensure that regular users can confidently and efficiently manage their workspace usage, contributing to an organized and adaptive hybrid work environment.

\subsection{Features for Administrators}

SeatSurfer provides administrators with essential tools to configure office layouts and monitor seat occupancy efficiently. These features are tailored to support hybrid workplace models, where flexibility, control, and real-time visibility are key requirements.

\begin{itemize}
    \item \textbf{Floor Configuration:}  
    Administrators can define individual floors by assigning them descriptive names and setting the number of rows and columns for the seating grid. This flexible setup allows each storey to reflect the physical dimensions of actual office spaces and supports multiple floors per building.

    \item \textbf{Interactive Layout Builder:}  
    Through an interactive grid-based editor, admins can selectively activate or deactivate individual cells. Each cell represents a potential seat, corridor, or wall segment. This interface makes it easy to:
    \begin{itemize}
        \item Model realistic floor plans
        \item Reactivate previously decommissioned seats
        \item Reflect temporary seating changes due to renovations or policies
    \end{itemize}

    \item \textbf{Statistics Dashboard:}  
    The dashboard presents real-time occupancy data based on selected dates and floors. It includes:
    \begin{itemize}
        \item Total number of seats on a floor
        \item Number of booked and available seats
        \item Occupancy percentage
    \end{itemize}
    This helps administrators monitor demand, detect underused areas, and optimize seat allocation strategies accordingly.
\end{itemize}

Overall, these administrator tools ensure that SeatSurfer remains adaptable to changing space requirements and offers a clear, user-friendly interface for managing layout and capacity.

\subsection{Design Philosophy and UI Decisions}

The design of SeatSurfer prioritizes clarity, responsiveness, and ease of use, with a strong emphasis on enabling users to perform critical actions with minimal friction. The overall goal is to provide a seamless experience across platforms while maintaining functional depth for both regular users and administrators.

\begin{itemize}
    \item \textbf{Minimalistic UI with prominent date selection and seat layout:}  
    The interface follows a clean, distraction-free design that places key actions (such as selecting a floor or choosing a date) at the center of the user flow. The seat matrix is visually intuitive, allowing users to quickly understand seat availability through color cues. Date selection and layout rendering patterns improve accessibility for non-technical users \cite{santos2022uxpatterns}.

    \item \textbf{Confirmation dialogs for critical actions:}  
    To prevent unintended actions, all operations such as booking a seat or navigating away from a filled form are gated behind confirmation prompts. This ensures that the user is always in control and can avoid mistakes.

    \item \textbf{Clear and informative error handling:}  
    User feedback is provided instantly and in context — for example, if a seat is already booked, the UI shows a non-intrusive but visible message. Backend validation is coupled with frontend hints, creating a consistent and helpful experience.

    \item \textbf{Responsive and mobile-friendly layout:}  
    The layout dynamically adjusts to different screen sizes. This includes scaling the seat matrix appropriately and reflowing input elements for smaller displays. The app was tested on various devices to ensure usability on both smartphones and desktops.
\end{itemize}

These design decisions were informed by best practices in modern UI/UX development, ensuring that even users with limited technical knowledge can navigate the system comfortably. For administrators, the interface presents data in an actionable format, making it easy to oversee space usage and configuration.

\subsection{Testing Strategy}

To ensure correctness, reliability, and security, SeatSurfer underwent a comprehensive testing process combining automated and manual methods. Testing focused on validating core functionality, backend robustness, frontend behavior, and access control enforcement.

\subsection*{1. Unit Testing (Backend)}

The backend logic was tested using the JUnit framework in combination with Mockito for mocking dependencies. These tests targeted the service layer, ensuring that business rules were enforced independently of the database or frontend.

\begin{itemize}
    \item \textbf{Booking conflict prevention:} Tested scenarios where a user attempted to book an already reserved seat for a given date. The system correctly rejected these with informative error responses.
    \item \textbf{Booking cancellation logic:} Verified that users could only cancel their own bookings and that deletions correctly propagated to the database.
    \item \textbf{Role-based filtering:} Ensured that administrative logic (e.g., retrieving all bookings) was properly limited to authorized users.
\end{itemize}

\subsection*{2. API Testing (Manual + Postman)}

The REST API was extensively tested through Postman collections simulating real usage flows. Both valid and invalid requests were evaluated to confirm system stability and adherence to expected behaviors.

\begin{itemize}
    \item \textbf{Happy path tests:} Booking a seat for an available date, then retrieving and canceling it successfully.
    \item \textbf{Conflict scenarios:} Trying to book a seat that was already reserved, ensuring the API returned meaningful HTTP errors (409 or 400).
    \item \textbf{Invalid access:} Accessing user- or admin-only endpoints with insufficient permissions returned appropriate HTTP 401/403 codes.
    \item \textbf{Edge case validation:} Submitting malformed JSON or missing parameters was gracefully handled without crashing the server.
\end{itemize}

\subsection*{3. Manual Frontend Testing}

The Flutter application was tested manually on both desktop and mobile environments to ensure visual consistency, responsiveness, and feature completeness.

\begin{itemize}
    \item \textbf{Browser and device compatibility:} Tested in Google Chrome, Android Emulator, and on a physical Pixel 5 device.
    \item \textbf{Responsive behavior:} Verified correct rendering and usability across screen sizes from smartphones to laptops.
    \item \textbf{State management validation:} Ensured consistency when navigating between views (e.g., booking screen to booking list and back) and after performing actions such as canceling a seat.
    \item \textbf{Performance under load:} Particular attention was paid to rendering performance when loading large seat layouts or analytics dashboards, in line with best practices for Flutter performance optimization \cite{garcia2021flutterperf}.
\end{itemize}

\subsection*{4. Access Control Testing}

Security-related tests focused on validating role-based restrictions and session behavior.

\begin{itemize}
    \item \textbf{Role enforcement:} Verified that regular users were blocked from accessing administrative views and actions, and that admins had unrestricted access.
    \item \textbf{Session timeout and logout behavior:} Confirmed that expired sessions led to automatic redirection to the login page and that logout endpoints invalidated active sessions.
    \item \textbf{JWT/session testing (if applicable):} Ensured headers were required for protected endpoints and tokens could not be reused or tampered with.
\end{itemize}

This multi-layered testing approach ensured that SeatSurfer was functionally correct, secure against unauthorized access, and robust across platforms.

\subsection{User and Administrator Manual}

This section serves as a practical guide for navigating the SeatSurfer application. It covers all core workflows for both regular users and administrators, providing detailed instructions and interface walkthroughs. SeatSurfer was designed with usability in mind, offering an intuitive interface and streamlined seat management process.

\subsection*{User Functionality}

\subsubsection*{1. Sign-Up and Login}

Users can register by providing an email address and a password. After successful registration, they can log in and begin booking.

\begin{center}
\includegraphics[width=0.35\textwidth]{images/login_screen.png}
\captionof{figure}{User Registration Screen}
\end{center}

\subsubsection*{2. Visual Seat Selection and Booking}

Once logged in, the user is presented with a grid-based seat layout for a selected storey and date. Seats are color-coded:

\begin{itemize}
\item \textcolor{red}{Red} — booked
\item \textcolor{gray}{Gray} — unavailable
\item \textcolor{green}{Green} — available
\item \textcolor{purple}{Purple} — suggested by AI
\end{itemize}

\begin{center}
\includegraphics[width=0.35\textwidth]{images/Simulator Screenshot - iPhone 16 Pro Max - 2025-05-19 at 19.56.13.png}
\captionof{figure}{Seat Selection and Layout}
\end{center}

\subsubsection*{3. View and Manage Bookings}

Users can access the “Your Bookings” screen to view upcoming and past reservations. Each booking displays the seat ID, date, and a trash icon for deletion.

\begin{center}
\includegraphics[width=0.35\textwidth]{images/Simulator Screenshot - iPhone 16 Pro Max - 2025-05-19 at 20.04.04.png}
\captionof{figure}{Upcoming Bookings List}
\end{center}

Tapping a booking shows seat details such as row, column, and storey:

\begin{center}
\includegraphics[width=0.35\textwidth]{images/Simulator Screenshot - iPhone 16 Pro Max - 2025-05-19 at 20.04.14.png}
\captionof{figure}{Booking Details Modal}
\end{center}

Bookings can also be deleted. After deletion, a confirmation message is displayed.

\begin{center}
\includegraphics[width=0.35\textwidth]{images/Simulator Screenshot - iPhone 16 Pro Max - 2025-05-19 at 20.04.30.png}
\captionof{figure}{Deleted Booking Confirmation}
\end{center}

\subsection*{Admin Functionality}

\subsubsection*{1. Storey and Building Management}

Admins can manage multiple buildings, each with several storeys. They can view associated storeys and access occupancy statistics for each.

\begin{center}
\includegraphics[width=0.35\textwidth]{images/Simulator Screenshot - iPhone 16 Pro Max - 2025-05-19 at 20.06.31.png}
\captionof{figure}{Buildings and Storeys Management}
\end{center}

\subsubsection*{2. Occupancy Analytics}

Admins can select a date range and storey to generate occupancy data including total seats, booked/unbooked counts, and occupancy percentage.

\begin{center}
\includegraphics[width=0.35\textwidth]{images/Simulator Screenshot - iPhone 16 Pro Max - 2025-05-19 at 20.07.03.png}
\captionof{figure}{Occupancy Analytics Dashboard}
\end{center}

\subsubsection*{3. Seat Layout Configuration}

Admins can design seat layouts by selecting the storey and building, then activating or deactivating seat positions in a grid-based interface.

\begin{center}
\includegraphics[width=0.35\textwidth]{images/Simulator Screenshot - iPhone 16 Pro Max - 2025-05-19 at 20.08.52.png}
\captionof{figure}{Interactive Seat Layout Designer}
\end{center}

\subsection*{Error Handling and Notifications}

Throughout the application, feedback is provided for all actions:
\begin{itemize}
    \item Booking conflict errors (e.g., seat already reserved)
    \item Unauthorized access redirections
    \item Confirmation dialogs for all destructive actions (e.g., canceling)
    \item Visual loading indicators during API operations
\end{itemize}

\subsection{Test Results and Known Limitations}

Extensive testing demonstrated that the core functionality of the SeatSurfer platform operates reliably under typical usage scenarios. However, several limitations were identified, particularly related to edge cases and user experience on mobile devices.

\begin{itemize}
    \item \textbf{Booking logic validation:} The backend consistently enforced constraints to prevent double bookings and ensured that seat selection respected availability and layout constraints.
    
    \item \textbf{Layout rendering accuracy:} Seat matrices were correctly generated based on the configured floor dimensions and seat activation settings. Visual feedback (e.g., booked, available, inactive colors) functioned as intended across test environments.

    \item \textbf{Mobile layout scalability:} On devices with smaller screens, especially when displaying floors with more than 15 rows, UI elements such as seat buttons became cramped, impacting usability. This can be addressed in future versions by enabling zoom/pan or implementing a scrollable seat grid.

    \item \textbf{Session handling behavior:} In some cases, authenticated sessions expired faster than expected, especially when the app was left idle in the background. This was traced to conservative timeout defaults, which can be tuned in the Spring Security configuration for a better balance between security and user convenience.
\end{itemize}

Despite these limitations, no critical failures or data integrity issues were encountered. All test scenarios confirmed that the application adheres to its core design goals of reliability, security, and responsiveness.

\newpage


% ===== CHAPTER 9 =====
\section{AI-Based Seat Suggestion Engine}

\subsection{Overview}

A standout innovation in SeatSurfer is the integration of an AI-powered seat suggestion feature, designed to streamline decision-making in dynamic hybrid work environments. As employees alternate between remote and on-site schedules, the process of manually selecting a seat each time can become tedious, inefficient, and prone to repetition or suboptimal choices.

The AI suggestion engine solves this by introducing intelligent, data-driven seat recommendations tailored to each user's behavior and contextual preferences. Rather than requiring users to browse through large seat grids, the system proactively analyzes their past booking patterns, seat popularity trends, and floor layout data to generate ranked suggestions for the most suitable seats.

This not only improves the user experience by reducing friction and saving time, but also contributes to better spatial distribution across floors — helping organizations prevent seat clustering, encourage equitable use of resources, and support ergonomic or team-based seating strategies.

By combining usability with personalization, the AI seat suggestion module transforms a routine action into a smart interaction, showcasing SeatSurfer's commitment to intelligent workplace optimization.

\subsection{Problem Statement}

In modern office environments — particularly those adopting hybrid or hot-desking models — selecting a seat is no longer a static, pre-assigned process. Instead, users are often presented with large, flexible layouts containing dozens or even hundreds of seats. This abundance of choice, while beneficial in theory, can lead to decision fatigue, inefficiency, and inconsistent seat utilization in practice.

Employees may have implicit preferences — such as proximity to colleagues, access to natural light, reduced noise levels, or even habitual use of certain areas — but without a system to recognize and support these preferences, users are left to manually browse and guess the best seat for each booking session. As the number of users and seats grows, this process becomes increasingly arbitrary and time-consuming.

Furthermore, unmanaged user behavior often results in seat clustering, overuse of preferred zones, and underutilization of available space. This imbalance not only affects comfort and productivity but also complicates occupancy analysis and planning.

To address these challenges, SeatSurfer introduces an AI-driven assistant that intelligently analyzes past booking behavior, personal patterns, and seat characteristics to infer user preferences. Based on this data, the system proactively suggests the most suitable available seats, offering a streamlined, personalized, and efficient seat selection experience — without requiring users to re-evaluate the entire layout each time they book. AI-based systems have emerged to support flexible work environments by personalizing seat assignments, further validating this approach \cite{lu2022ai}.

\subsection{System Architecture}

The AI-driven seat suggestion engine in SeatSurfer is designed as a modular, scalable, and loosely coupled component. It is implemented as a standalone Python-based microservice that operates independently from the core Spring Boot backend. This architectural choice enables separation of concerns, easier experimentation with machine learning models, and flexibility in deployment and scaling. Microservice architectures improve modularity and fault isolation in AI-based systems \cite{torres2023micro}.

The integration between the main application and the AI module is achieved through a stateless REST API, allowing seamless communication without tight dependencies. The end-to-end flow of a suggestion request is as follows:

\begin{itemize}
\item \textbf{Step 1 — User Interaction:}
The user initiates a recommendation by clicking the “Suggest a Seat” button within the Flutter-based frontend interface.
\item \textbf{Step 2 — Frontend API Call:}  
The frontend collects the necessary context — including the selected date, floor identifier, and the logged-in user's email — and sends this information as a request to the Spring Boot backend.
\item \textbf{Step 3 — Backend Orchestration:}  
The backend acts as an intermediary, formatting and forwarding the request to the AI microservice's \texttt{/suggest} endpoint. This request encapsulates the contextual metadata needed to generate a personalized recommendation.
\item \textbf{Step 4 — AI Microservice Processing:}  
Upon receiving the request, the AI service fetches historical booking data for the user, filters out already-booked or inactive seats, and calculates a preference score for each available seat based on behavioral and contextual criteria.
\item \textbf{Step 5 — Ranked Seat Response:}  
The microservice returns a sorted list of seat recommendations, typically including the best match followed by a few ranked alternatives. The backend forwards this list to the Flutter client.
\item \textbf{Step 6 — UI Highlighting:}  
On the user interface, the top recommended seat is visually highlighted (e.g., in primary purple), while other alternatives are shown with lighter gradients to indicate relative preference. The user retains full control to accept or override the suggestion.
\end{itemize}

This architecture ensures that the AI engine remains independent, easily replaceable, and adaptable — allowing future iterations to incorporate advanced models without disrupting the main application codebase. Additionally, the use of reactive programming models in the backend helps maintain responsiveness and scalability in handling real-time seat data and user interactions \cite{huang2023reactive}.

\subsection{Input Features and Scoring Logic}

The seat suggestion engine in SeatSurfer ranks available seats using a multi-factor scoring system designed to reflect both individual user preferences and collective seat usage patterns. The goal is to return the most contextually appropriate options based on historical behavior, usage trends, and temporal alignment.

The core input features used by the model are as follows:

\begin{itemize}
\item \textbf{User Booking History:}
The frequency with which a user has previously booked specific seats is a strong indicator of preference. The system assigns higher scores to seats the user has consistently chosen in the past, especially on similar days of the week or timeframes.
\item \textbf{Seat Popularity:}  
Popularity is measured based on how frequently a seat is booked across all users. Seats with moderate popularity may be favored, while avoiding overbooked or overused zones helps promote balanced space distribution and prevents bottlenecks.
\item \textbf{Temporal Proximity:}  
The model accounts for the day of the week and other temporal patterns in the user's past bookings. For instance, if a user tends to work on-site every Monday, the algorithm prioritizes seats booked on Mondays to reflect likely preferences for location and workflow.
\item \textbf{Seat Attributes (Seat Type):}  
Each seat may include tags such as “window seat,” “near exit,” or “corner.” These categorical features contribute to the seat's score when aligned with a user's implicit habits. For example, if the user frequently books seats near exits, such seats are ranked higher.
\end{itemize}

\subsection*{Scoring Formula}

The scoring mechanism uses a weighted linear formula that assigns a normalized score to each candidate seat:

\(\text{Score(seat)} = \alpha \cdot \text{History} + \beta \cdot \text{Popularity} + \gamma \cdot \text{TemporalMatch} + \delta \cdot \text{SeatTypeMatch}\)

Where:
\begin{itemize}
\item $\alpha, \beta, \gamma, \delta$ are configurable weights based on empirical performance
\item Each feature is normalized to a common scale (e.g., [0, 1]) before aggregation
\end{itemize}

After computing scores for all eligible seats, the system returns a ranked list, typically including the top suggestion and 2-3 high-confidence alternatives. These options are then passed to the UI for visual presentation and user selection.

\subsection*{Extensibility}

The scoring engine is designed to be modular and extensible. Future improvements may include:
\begin{itemize}
\item \textbf{Collaborative Filtering:} Learning from users with similar patterns to improve cold-start recommendations
\item \textbf{Feedback Loop:} Adjusting weights based on accepted or overridden suggestions
\item \textbf{Contextual Inputs:} Incorporating weather, noise zones, or team proximity for richer personalization
\item \textbf{Reinforcement Learning:} Adapting strategies over time based on real-world reward signals
\end{itemize}

This framework balances interpretability with personalization and lays the groundwork for scalable, data-driven decision support in the office space domain.

\subsection{REST API Integration}

The integration between the Spring Boot backend and the Python-based AI microservice is achieved through stateless RESTful communication. This separation ensures modularity and allows the AI engine to evolve independently from the main application logic. The interaction consists of a well-defined API contract where the backend acts as a proxy and orchestrator for AI-driven seat recommendations.

While REST remains the default protocol for communication, future versions of SeatSurfer could consider using GraphQL to allow clients to define their own query structures and reduce over-fetching in microservice-based recommendation flows \cite{wang2022graphql}.

\subsection*{Spring Boot Endpoint (Consumer)}

On the backend side, a REST controller exposes the \texttt{/api/suggest-seat} endpoint. When a user triggers a seat suggestion from the Flutter frontend, this endpoint receives relevant parameters and forwards them to the AI microservice:

\begin{lstlisting}[language=Java, caption=Spring Boot Controller]
@GetMapping("/api/suggest-seat")
public ResponseEntity<List<SeatSuggestionDTO>> suggestSeat(
    @RequestParam String email,
    @RequestParam Long floorId,
    @RequestParam String date) {
    
    List<SeatSuggestionDTO> suggestions = 
        suggestionService.getSuggestions(email, floorId, date);
        
    return ResponseEntity.ok(suggestions);
}
\end{lstlisting}

The controller uses a dedicated service class (\texttt{suggestionService}) to abstract the logic for calling the AI module, keeping the controller clean and testable.

\subsection*{Python Flask Microservice (Provider)}

The AI component is built as a lightweight Flask API with a single route for receiving and processing seat suggestion requests. This microservice can be scaled independently and enhanced with more complex logic or even swapped with another engine in the future.

\begin{lstlisting}[language=Python, caption=Python Flask Endpoint]
@app.route('/suggest', methods=['POST'])
def suggest_seat():
    data = request.json
    # Core logic: rank all available seats for the given user and context
    ranked_seats = ai_engine.rank_seats(
        email=data['email'],
        floor_id=data['floor_id'],
        date=data['date']
    )

    return jsonify(ranked_seats)
\end{lstlisting}

This endpoint expects a JSON payload with three fields: \texttt{email}, \texttt{floor\_id}, and \texttt{date}. It delegates the logic to a seat ranking engine (\texttt{ai\_engine}), which performs data analysis and returns a list of seats ordered by suitability.

\subsection*{Data Format and Response Structure}

The API contract ensures that the response returned to the frontend contains a ranked list of seat objects, each including:

\begin{itemize}
\item \texttt{seatId} - Unique identifier of the seat
\item \texttt{row}, \texttt{column} - Position on the floor layout
\item \texttt{score} - Relevance score (optional, for transparency/debugging)
\end{itemize}

This format ensures consistency across frontend and backend layers and enables seamless visual mapping in the Flutter UI.

\subsection{User Experience}

The AI-powered seat suggestion feature is designed to seamlessly enhance the user journey with minimal disruption to existing booking behavior. Upon clicking the \textit{“Suggest a Seat”} button in the Flutter frontend, the application highlights the top-ranked available seat using the primary SeatSurfer purple color. Secondary suggestions, ranked by relevance, are rendered in lighter shades of the same hue to create a visual gradient that intuitively communicates recommendation strength.

This visual hierarchy makes the decision process quick and intuitive. Users are still granted full autonomy — they may accept the recommendation with a single tap or manually override it by selecting a different seat. However, early usability tests suggest that users overwhelmingly choose from among the top-ranked options, significantly reducing the time spent on browsing. Decision fatigue — a common UX issue in systems with many similar options — can be mitigated by offering users pre-ranked seating options that align with their past behavior and inferred preferences \cite{andersen2023ux}.

Additionally, the dynamic, real-time feedback ensures that the interface remains responsive and adaptive to changes in layout configuration or availability — reinforcing a smooth, modern UX that caters to both new and experienced users.

\subsection{Benefits and Impact}

The seat suggestion engine brings tangible improvements to both user experience and organizational efficiency. Its value extends beyond convenience, introducing strategic benefits at the intersection of personalization and optimization:

\begin{itemize}
\item \textbf{Time-saving Efficiency:}
By automating the decision process, the system removes the friction of browsing large seating matrices — especially during high-traffic booking periods — and reduces cognitive load for users.
\item \textbf{Personalized Experience:}  
The model tailors suggestions based on past behavior and contextual cues, ensuring users feel understood and supported in their workspace preferences. This level of personalization fosters trust in the system and boosts overall satisfaction.
\item \textbf{Optimized Resource Utilization:}  
By subtly guiding users toward underutilized areas without enforcing rigid rules, the algorithm helps distribute occupancy more evenly. This avoids overcrowding in popular zones while maximizing the use of available space.
\item \textbf{Scalability and Adaptability:}  
The modular architecture allows the AI system to grow alongside the application. It can be extended to support advanced use cases such as group bookings (e.g., suggest adjacent seats for teams), department-aware clustering, or even predictive booking behavior based on calendar events and schedules.
\end{itemize}

Collectively, these benefits position the AI engine not just as a convenience feature, but as a smart optimization layer that transforms SeatSurfer into a forward-thinking workplace management tool.

\newpage

% ===== CHAPTER 10 =====
\chapter{Future Enhancements and Research Directions}

\section{Overview}

SeatSurfer already provides solid core features—seat booking, access control, and admin configuration. However, its architecture was deliberately designed for long-term extensibility, allowing new capabilities to be added incrementally.

This chapter outlines a forward-looking roadmap focused on three key areas of improvement:

\begin{itemize}
    \item \textbf{Intelligent Features} — AI-driven tools such as predictive booking, preference learning, and automated seat assignment to optimize space usage and user experience \cite{nguyen2023predictive}.
    \item \textbf{Enhanced User Experience} — Integration of drag-and-drop reservations, real-time collaboration, and calendar sync for a more intuitive interface.
    \item \textbf{IoT and Sensor Integration} — Incorporating desk sensors, QR check-ins, and occupancy tracking to bridge digital bookings with physical presence.
\end{itemize}

These enhancements position SeatSurfer not just as a reservation tool, but as a future-ready, intelligent workspace management platform.

Here's a refined and reworded version of the Conclusion that maintains your message while changing the phrasing and structure for originality and variety:

\section{Conclusion}

SeatSurfer represents more than just a booking platform—it lays the groundwork for intelligent workspace management in the age of hybrid work. By embracing modular design, scalable architecture, and a focus on real-time data handling, the system responds effectively to the evolving needs of flexible office environments.

Although the platform currently delivers essential features such as seat reservations, role-specific access, and occupancy tracking, it was built with future enhancements in mind. Its design accommodates the integration of AI-driven suggestions, IoT-based presence detection, and in-depth analytics, without requiring fundamental changes to the system’s core.

This project exemplifies how a thoughtfully designed full-stack application can grow from a focused tool into a smart orchestration layer for modern offices—enabling adaptive decision-making, automation, and personalized user experiences.

As workplace dynamics continue to shift, solutions like SeatSurfer will play a vital role in shaping environments that are not only efficient and responsive, but also proactive in supporting collaboration, comfort, and sustainable resource usage.

\newpage

\appendix

\chapter{Entity Class Example (Java)}
\label{appendix:entity}

\begin{lstlisting}[language=Java, caption=Seat Entity (Java), label=lst:seat-entity]
@Entity
public class Seat {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private int row;
    private int column;

    @ManyToOne
    @JoinColumn(name = "floor_id", nullable = false)
    private Floor floor;

    private boolean active;

    // getters and setters
}
\end{lstlisting}

\chapter{REST Controller Sample}
\label{appendix:controller}

\begin{lstlisting}[language=Java, caption=Booking Controller (Java), label=lst:booking-controller]
@RestController
@RequestMapping("/api/bookings")
public class BookingController {

    @Autowired
    private BookingService bookingService;

    @PostMapping
    public ResponseEntity<?> createBooking(@RequestBody BookingDTO bookingDTO) {
        return ResponseEntity.ok(bookingService.book(bookingDTO));
    }

    @DeleteMapping("/{id}")
    public void deleteBooking(@PathVariable Long id) {
        bookingService.cancel(id);
    }
}
\end{lstlisting}

\chapter{SeatSuggestionDTO Example (Java)}
\label{appendix:seatdto}

\begin{lstlisting}[language=Java, caption=SeatSuggestionDTO (Java), label=lst:seat-suggestion-dto]
public class SeatSuggestionDTO {
    private Long seatId;
    private int row;
    private int column;
    private double score;

    // Constructors, getters, and setters
}
\end{lstlisting}

\chapter{Python Microservice Endpoint}
\label{appendix:microservice}

\begin{lstlisting}[language=Python, caption=Seat Suggestion Endpoint (Flask), label=lst:python-endpoint]
@app.route('/suggest', methods=['POST'])
def suggest_seat():
    data = request.json
    ranked_seats = ai_engine.rank_seats(
        email=data['email'],
        floor_id=data['floor_id'],
        date=data['date']
    )
    return jsonify(ranked_seats)
\end{lstlisting}

\chapter{SQL Table Definitions}
\label{appendix:sql}

\begin{lstlisting}[language=SQL, caption=Database Schema, label=lst:sql-schema]
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password TEXT NOT NULL,
    role VARCHAR(50)
);

CREATE TABLE floors (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE seats (
    id BIGSERIAL PRIMARY KEY,
    floor_id BIGINT REFERENCES floors(id),
    row INT,
    column INT,
    active BOOLEAN DEFAULT TRUE
);

CREATE TABLE bookings (
    id BIGSERIAL PRIMARY KEY,
    seat_id BIGINT REFERENCES seats(id),
    user_id BIGINT REFERENCES users(id),
    booking_date DATE NOT NULL
);
\end{lstlisting}

\chapter{Flutter Seat Widget Example}
\label{appendix:flutter}

\begin{lstlisting}[language=Java, caption=Seat Booking Widget (Flutter), label=lst:flutter-ui]
Widget buildSeat(int row, int col) {
  final isBooked = bookedSeats.contains(SeatPosition(row, col));
  return GestureDetector(
    onTap: () => onSeatTap(row, col),
    child: Container(
      margin: EdgeInsets.all(4),
      width: 40,
      height: 40,
      decoration: BoxDecoration(
        color: isBooked ? Colors.red : Colors.green,
        borderRadius: BorderRadius.circular(6),
      ),
    ),
  );
}
\end{lstlisting}

\chapter{Scoring Function (Python)}
\label{appendix:scoring}

\begin{lstlisting}[language=Python, caption=Seat Scoring Function (Python), label=lst:scoring-function]
def score_seat(history_score, popularity, temporal, type_match):
    alpha = 0.4
    beta = 0.3
    gamma = 0.2
    delta = 0.1
    return (alpha * history_score +
            beta * popularity +
            gamma * temporal +
            delta * type_match)
\end{lstlisting}

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}